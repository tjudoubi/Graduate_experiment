(program (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (literal "use strict"))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable sinhOfFour) = (singleExpression (singleExpression (singleExpression Math) . (identifierName sinh)) (arguments ( (argument (singleExpression (literal (numericLiteral 4)))) ))))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable validInputTestCases) = (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "undefined"))) , (arrayElement (singleExpression (literal "NaN")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "null"))) , (arrayElement (singleExpression (literal "0")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "0"))) , (arrayElement (singleExpression (literal "0")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "-0."))) , (arrayElement (singleExpression (literal "-0")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "4"))) , (arrayElement (singleExpression (singleExpression (literal "")) + (singleExpression sinhOfFour)))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "Math.PI"))) , (arrayElement (singleExpression (singleExpression (literal "")) + (singleExpression (singleExpression (singleExpression Math) . (identifierName sinh)) (arguments ( (argument (singleExpression (singleExpression Math) . (identifierName PI))) )))))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "Infinity"))) , (arrayElement (singleExpression (literal "Infinity")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "-Infinity"))) , (arrayElement (singleExpression (literal "-Infinity")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "NaN"))) , (arrayElement (singleExpression (literal "NaN")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "\"WebKit\""))) , (arrayElement (singleExpression (literal "NaN")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "\"4\""))) , (arrayElement (singleExpression (singleExpression (literal "")) + (singleExpression sinhOfFour)))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "{ valueOf: () => { return 4; } }"))) , (arrayElement (singleExpression (singleExpression (literal "")) + (singleExpression sinhOfFour)))) ]))) ,) ])))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable validInputTypedTestCases) = (singleExpression (singleExpression (singleExpression validInputTestCases) . (identifierName map)) (arguments ( (argument (singleExpression (anoymousFunction (arrowFunctionParameters ( (formalParameterList (formalParameterArg (assignable element))) )) => (arrowFunctionBody { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (singleExpression eval) (arguments ( (argument (singleExpression (singleExpression (singleExpression (literal "(")) + (singleExpression (singleExpression element) [ (expressionSequence (singleExpression (literal (numericLiteral 0)))) ])) + (singleExpression (literal ")")))) )))) , (arrayElement (singleExpression (singleExpression eval) (arguments ( (argument (singleExpression (singleExpression element) [ (expressionSequence (singleExpression (literal (numericLiteral 1)))) ])) ))))) ]))) eos))))) })))) ))))) (eos ;)))) (sourceElement (statement (functionDeclaration function isIdentical ( (formalParameterList (formalParameterArg (assignable result)) , (formalParameterArg (assignable expected))) ) { (functionBody (sourceElements (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression expected) === (singleExpression expected))) ) (statement (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression result) !== (singleExpression expected))) ) (statement (returnStatement return (expressionSequence (singleExpression (literal false))) (eos ;))))) (statement (ifStatement if ( (expressionSequence (singleExpression ! (singleExpression expected))) ) (statement (returnStatement return (expressionSequence (singleExpression (singleExpression ( (expressionSequence (singleExpression (singleExpression (literal (numericLiteral 1))) / (singleExpression expected))) )) === (singleExpression ( (expressionSequence (singleExpression (singleExpression (literal (numericLiteral 1))) / (singleExpression result))) )))) (eos ;))))) (statement (returnStatement return (expressionSequence (singleExpression (literal true))) (eos ;)))) }))))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression result) !== (singleExpression result))) (eos ;)))))) }))) (sourceElement (statement (functionDeclaration function opaqueSinhNoArgument ( ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression (singleExpression Math) . (identifierName sinh)) (arguments ( )))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueSinhNoArgument)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueSinhNoArgument)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testNoArgument ( ) { (functionBody (sourceElements (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e4))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable output) = (singleExpression (singleExpression opaqueSinhNoArgument) (arguments ( ))))) (eos ;))) (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression output) === (singleExpression output))) ) (statement (block { (statementList (statement (throwStatement throw (expressionSequence (singleExpression (literal "Failed opaqueSinhNoArgument"))) (eos ;)))) }))))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueSinhNoArgument)) ))) > (singleExpression (literal (numericLiteral 1))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "The call without arguments should never exit."))) (eos ;)))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testNoArgument) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueAllTypesSinh ( (formalParameterList (formalParameterArg (assignable argument))) ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression (singleExpression Math) . (identifierName sinh)) (arguments ( (argument (singleExpression argument)) )))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueAllTypesSinh)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueAllTypesSinh)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testAllTypesCall ( ) { (functionBody (sourceElements (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e3))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable testCaseInput))) of (expressionSequence (singleExpression validInputTypedTestCases)) ) (statement (block { (statementList (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable output) = (singleExpression (singleExpression opaqueAllTypesSinh) (arguments ( (argument (singleExpression (singleExpression testCaseInput) [ (expressionSequence (singleExpression (literal (numericLiteral 0)))) ])) ))))) (eos ;))) (statement (ifStatement if ( (expressionSequence (singleExpression ! (singleExpression (singleExpression isIdentical) (arguments ( (argument (singleExpression output)) , (argument (singleExpression (singleExpression testCaseInput) [ (expressionSequence (singleExpression (literal (numericLiteral 1)))) ])) ))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (singleExpression (singleExpression (singleExpression (singleExpression (singleExpression (literal "Failed testAllTypesCall for input ")) + (singleExpression (singleExpression testCaseInput) [ (expressionSequence (singleExpression (literal (numericLiteral 0)))) ])) + (singleExpression (literal " expected "))) + (singleExpression (singleExpression testCaseInput) [ (expressionSequence (singleExpression (literal (numericLiteral 1)))) ])) + (singleExpression (literal " got "))) + (singleExpression output))) (eos ;)))))) }))))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueAllTypesSinh)) ))) > (singleExpression (literal (numericLiteral 2))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "We should have detected sinh() was polymorphic and generated a generic version."))) (eos ;)))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testAllTypesCall) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testSingleTypeCall ( ) { (functionBody (sourceElements (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable testCaseInput))) of (expressionSequence (singleExpression validInputTestCases)) ) (statement (block { (statementList (statement (expressionStatement (expressionSequence (singleExpression (singleExpression eval) (arguments ( (argument (singleExpression (literal `            function opaqueSinh(argument) {                return Math.sinh(argument);            }            noInline(opaqueSinh);            noOSRExitFuzzing(opaqueSinh);            for (let i = 0; i < 1e4; ++i) {                if (!isIdentical(opaqueSinh(${testCaseInput[0]}), ${testCaseInput[1]})) {                    throw "Failed testSingleTypeCall()";                }            }            if (numberOfDFGCompiles(opaqueSinh) > 1)                throw "We should have compiled a single sinh for the expected type.";        `))) )))) (eos ;)))) }))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testSingleTypeCall) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testConstant ( ) { (functionBody (sourceElements (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable testCaseInput))) of (expressionSequence (singleExpression validInputTestCases)) ) (statement (block { (statementList (statement (expressionStatement (expressionSequence (singleExpression (singleExpression eval) (arguments ( (argument (singleExpression (literal `            function opaqueSinhOnConstant() {                return Math.sinh(${testCaseInput[0]});            }            noInline(opaqueSinhOnConstant);            noOSRExitFuzzing(opaqueSinhOnConstant);            for (let i = 0; i < 1e4; ++i) {                if (!isIdentical(opaqueSinhOnConstant(), ${testCaseInput[1]})) {                    throw "Failed testConstant()";                }            }            if (numberOfDFGCompiles(opaqueSinhOnConstant) > 1)                throw "We should have compiled a single sinh for the expected type.";        `))) )))) (eos ;)))) }))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testConstant) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueSinhForSideEffects ( (formalParameterList (formalParameterArg (assignable argument))) ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression (singleExpression Math) . (identifierName sinh)) (arguments ( (argument (singleExpression argument)) )))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueSinhForSideEffects)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueSinhForSideEffects)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testSideEffect ( ) { (functionBody (sourceElements (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable testObject) = (singleExpression (objectLiteral { (propertyAssignment (propertyName (identifierName counter)) : (singleExpression (literal (numericLiteral 0)))) , (propertyAssignment (propertyName (identifierName valueOf)) : (singleExpression (anoymousFunction function ( ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression ++ (singleExpression (singleExpression this) . (identifierName counter)))) (eos ;)))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (literal (numericLiteral 16)))) (eos ;)))))) }))) })))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable sinh16) = (singleExpression (singleExpression (singleExpression Math) . (identifierName sinh)) (arguments ( (argument (singleExpression (literal (numericLiteral 16)))) ))))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e4))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression opaqueSinhForSideEffects) (arguments ( (argument (singleExpression testObject)) ))) !== (singleExpression sinh16))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "Incorrect result in testSideEffect()"))) (eos ;)))))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression testObject) . (identifierName counter)) !== (singleExpression (literal (numericLiteral 1e4))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "Failed testSideEffect()"))) (eos ;)))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueSinhForSideEffects)) ))) > (singleExpression (literal (numericLiteral 1))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "opaqueSinhForSideEffects() is predictable, it should only be compiled once."))) (eos ;)))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testSideEffect) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueSinhForCSE ( (formalParameterList (formalParameterArg (assignable argument))) ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression (singleExpression (singleExpression (singleExpression Math) . (identifierName sinh)) (arguments ( (argument (singleExpression argument)) ))) + (singleExpression (singleExpression (singleExpression Math) . (identifierName sinh)) (arguments ( (argument (singleExpression argument)) )))) + (singleExpression (singleExpression (singleExpression Math) . (identifierName sinh)) (arguments ( (argument (singleExpression argument)) ))))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueSinhForCSE)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueSinhForCSE)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testCSE ( ) { (functionBody (sourceElements (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable testObject) = (singleExpression (objectLiteral { (propertyAssignment (propertyName (identifierName counter)) : (singleExpression (literal (numericLiteral 0)))) , (propertyAssignment (propertyName (identifierName valueOf)) : (singleExpression (anoymousFunction function ( ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression ++ (singleExpression (singleExpression this) . (identifierName counter)))) (eos ;)))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (literal (numericLiteral 16)))) (eos ;)))))) }))) })))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable sinh16) = (singleExpression (singleExpression (singleExpression Math) . (identifierName sinh)) (arguments ( (argument (singleExpression (literal (numericLiteral 16)))) ))))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable threeSinh16) = (singleExpression (singleExpression (singleExpression sinh16) + (singleExpression sinh16)) + (singleExpression sinh16)))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e4))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression opaqueSinhForCSE) (arguments ( (argument (singleExpression testObject)) ))) !== (singleExpression threeSinh16))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "Incorrect result in testCSE()"))) (eos ;)))))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression testObject) . (identifierName counter)) !== (singleExpression (literal (numericLiteral 3e4))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "Failed testCSE()"))) (eos ;)))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueSinhForCSE)) ))) > (singleExpression (literal (numericLiteral 1))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "opaqueSinhForCSE() is predictable, it should only be compiled once."))) (eos ;)))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testCSE) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueSinhForDCE ( (formalParameterList (formalParameterArg (assignable argument))) ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression (singleExpression Math) . (identifierName sinh)) (arguments ( (argument (singleExpression argument)) )))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueSinhForDCE)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueSinhForDCE)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testDCE ( ) { (functionBody (sourceElements (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable testObject) = (singleExpression (objectLiteral { (propertyAssignment (propertyName (identifierName counter)) : (singleExpression (literal (numericLiteral 0)))) , (propertyAssignment (propertyName (identifierName valueOf)) : (singleExpression (anoymousFunction function ( ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression ++ (singleExpression (singleExpression this) . (identifierName counter)))) (eos ;)))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (literal (numericLiteral 16)))) (eos ;)))))) }))) })))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e4))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (expressionStatement (expressionSequence (singleExpression (singleExpression opaqueSinhForDCE) (arguments ( (argument (singleExpression testObject)) )))) (eos ;)))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression testObject) . (identifierName counter)) !== (singleExpression (literal (numericLiteral 1e4))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "Failed testDCE()"))) (eos ;)))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueSinhForDCE)) ))) > (singleExpression (literal (numericLiteral 1))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "opaqueSinhForDCE() is predictable, it should only be compiled once."))) (eos ;)))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testDCE) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testException ( ) { (functionBody (sourceElements (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable counter) = (singleExpression (literal (numericLiteral 0))))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueSinhWithException ( (formalParameterList (formalParameterArg (assignable argument))) ) { (functionBody (sourceElements (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable result) = (singleExpression (singleExpression (singleExpression Math) . (identifierName sinh)) (arguments ( (argument (singleExpression argument)) ))))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression ++ (singleExpression counter))) (eos ;)))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression result)) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueSinhWithException)) )))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable testObject) = (singleExpression (objectLiteral { (propertyAssignment (propertyName (identifierName valueOf)) : (singleExpression (anoymousFunction (arrowFunctionParameters ( )) => (arrowFunctionBody { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (literal (numericLiteral 64)))) (eos ;)))))) })))) })))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable sinh64) = (singleExpression (singleExpression (singleExpression Math) . (identifierName sinh)) (arguments ( (argument (singleExpression (literal (numericLiteral 64)))) ))))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e3))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression opaqueSinhWithException) (arguments ( (argument (singleExpression testObject)) ))) !== (singleExpression sinh64))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "Incorrect result in opaqueSinhWithException()"))) (eos ;)))))) }))))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable testThrowObject) = (singleExpression (objectLiteral { (propertyAssignment (propertyName (identifierName valueOf)) : (singleExpression (anoymousFunction (arrowFunctionParameters ( )) => (arrowFunctionBody { (functionBody (sourceElements (sourceElement (statement (throwStatement throw (expressionSequence (singleExpression testObject)) (eos ;)))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (literal (numericLiteral 64)))) (eos ;)))))) })))) })))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e2))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (tryStatement try (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression opaqueSinhWithException) (arguments ( (argument (singleExpression testThrowObject)) ))) !== (singleExpression (literal (numericLiteral 8))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "This code should not be reached!!"))) (eos ;)))))) }) (catchProduction catch ( (assignable e) ) (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression e) !== (singleExpression testObject))) ) (statement (block { (statementList (statement (throwStatement throw (expressionSequence (singleExpression (literal "Wrong object thrown from opaqueSinhWithException."))) eos))) }))))) }))))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression counter) !== (singleExpression (literal (numericLiteral 1e3))))) ) (statement (block { (statementList (statement (throwStatement throw (expressionSequence (singleExpression (literal "Invalid count in testException()"))) (eos ;)))) }))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testException) (arguments ( )))) (eos ;))))) <EOF>)