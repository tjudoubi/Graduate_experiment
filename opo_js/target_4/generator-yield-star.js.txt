(program (sourceElements (sourceElement (statement (functionDeclaration function shouldBe ( (formalParameterList (formalParameterArg (assignable actual)) , (formalParameterArg (assignable expected))) ) { (functionBody (sourceElements (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression actual) !== (singleExpression expected))) ) (statement (throwStatement throw (expressionSequence (singleExpression new (singleExpression (singleExpression Error) (arguments ( (argument (singleExpression (singleExpression (literal 'bad value: ')) + (singleExpression actual))) ))))) (eos ;)))))))) }))) (sourceElement (statement (functionDeclaration function shouldThrow ( (formalParameterList (formalParameterArg (assignable func)) , (formalParameterArg (assignable errorMessage))) ) { (functionBody (sourceElements (sourceElement (statement (variableStatement (variableDeclarationList (varModifier var) (variableDeclaration (assignable errorThrown) = (singleExpression (literal false)))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier var) (variableDeclaration (assignable error) = (singleExpression (literal null)))) (eos ;)))) (sourceElement (statement (tryStatement try (block { (statementList (statement (expressionStatement (expressionSequence (singleExpression (singleExpression func) (arguments ( )))) (eos ;)))) }) (catchProduction catch ( (assignable e) ) (block { (statementList (statement (expressionStatement (expressionSequence (singleExpression (singleExpression errorThrown) = (singleExpression (literal true)))) (eos ;))) (statement (expressionStatement (expressionSequence (singleExpression (singleExpression error) = (singleExpression e))) (eos ;)))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression ! (singleExpression errorThrown))) ) (statement (throwStatement throw (expressionSequence (singleExpression new (singleExpression (singleExpression Error) (arguments ( (argument (singleExpression (literal 'not thrown'))) ))))) (eos ;)))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression String) (arguments ( (argument (singleExpression error)) ))) !== (singleExpression errorMessage))) ) (statement (throwStatement throw (expressionSequence (singleExpression new (singleExpression (singleExpression Error) (arguments ( (argument (singleExpression (literal `bad error: ${String(error)}`))) ))))) (eos ;)))))))) }))) (sourceElement (statement (classDeclaration class CallSite (classTail { (classElement (methodDefinition (propertyName (identifierName constructor)) ( ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression (singleExpression this) . (identifierName count)) = (singleExpression (literal (numericLiteral 0))))) (eos ;)))))) })) (classElement (methodDefinition (propertyName (identifierName call)) ( ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression (singleExpression this) . (identifierName count)) ++)) (eos ;)))))) })) })))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression ( (expressionSequence (singleExpression (anoymousFunction function ( ) { (functionBody (sourceElements (sourceElement (statement (classDeclaration class Arrays (classTail { (classElement (methodDefinition (propertyName (identifierName constructor)) ( ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression (singleExpression this) . (identifierName first)) = (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal (numericLiteral 0)))) , (arrayElement (singleExpression (literal (numericLiteral 1)))) , (arrayElement (singleExpression (literal (numericLiteral 2)))) , (arrayElement (singleExpression (literal (numericLiteral 3))))) ])))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression (singleExpression this) . (identifierName second)) = (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal (numericLiteral 4)))) , (arrayElement (singleExpression (literal (numericLiteral 5)))) , (arrayElement (singleExpression (literal (numericLiteral 6)))) , (arrayElement (singleExpression (literal (numericLiteral 7))))) ])))) (eos ;)))))) })) (classElement (methodDefinition * (propertyName [ (singleExpression (singleExpression Symbol) . (identifierName iterator)) ]) ( ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression yield) * (singleExpression (singleExpression this) . (identifierName first)))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression yield) * (singleExpression (singleExpression this) . (identifierName second)))) (eos ;)))))) })) })))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier var) (variableDeclaration (assignable arrays) = (singleExpression new (singleExpression Arrays)))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression let)) eos))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression i) = (singleExpression (literal (numericLiteral 0))))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (singleExpression let) value))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression of)) eos))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression arrays)) eos))))) <missing '}'>))) ))) eos))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression shouldBe) (arguments ( (argument (singleExpression (singleExpression i) ++)) , (argument (singleExpression value)) )))) (eos ;))))) } ( ) ) ; ( function ( ) { let c1 = new CallSite ; class Iterator { next ( value ) { return { value , done : false } ; } 'throw' ( value ) { shouldBe ( value , 42 ) ; c1 . call ( ) ; throw new Error ( "OK" ) ; } [ Symbol . iterator ] ( ) { return this ; } } function * gen ( ) { let iter = new Iterator ( ) ; yield * iter ; } let g = gen ( ) ; shouldBe ( g . next ( 0 ) . value , undefined ) ; shouldBe ( g . next ( 1 ) . value , 1 ) ; shouldBe ( g . next ( 2 ) . value , 2 ) ; shouldThrow ( ( ) => { g . throw ( 42 ) ; } , `Error: OK` ) ; shouldThrow ( ( ) => { g . throw ( 44 ) ; } , `44` ) ; shouldBe ( c1 . count , 1 ) ; } ( ) ) ; ( function ( ) { let c1 = new CallSite ; class Iterator { next ( value ) { return { value , done : false } ; } 'return' ( value ) { shouldBe ( value , undefined ) ; c1 . call ( ) ; return { value , done : true } ; } [ Symbol . iterator ] ( ) { return this ; } } function * gen ( ) { let iter = new Iterator ( ) ; yield * iter ; } let g = gen ( ) ; shouldBe ( g . next ( 0 ) . value , undefined ) ; shouldBe ( g . next ( 1 ) . value , 1 ) ; shouldBe ( g . next ( 2 ) . value , 2 ) ; shouldThrow ( ( ) => { g . throw ( 42 ) ; } , `TypeError: Delegated generator does not have a 'throw' method.` ) ; shouldThrow ( ( ) => { g . throw ( 44 ) ; } , `44` ) ; shouldBe ( c1 . count , 1 ) ; } ( ) ) ; ( function ( ) { let c1 = new CallSite ; class Iterator { next ( value ) { return { value , done : false } ; } 'return' ( value ) { shouldBe ( value , undefined ) ; c1 . call ( ) ; } [ Symbol . iterator ] ( ) { return this ; } } function * gen ( ) { let iter = new Iterator ( ) ; yield * iter ; } let g = gen ( ) ; shouldBe ( g . next ( 0 ) . value , undefined ) ; shouldBe ( g . next ( 1 ) . value , 1 ) ; shouldBe ( g . next ( 2 ) . value , 2 ) ; shouldThrow ( ( ) => { g . throw ( 42 ) ; } , `TypeError: Iterator result interface is not an object.` ) ; shouldThrow ( ( ) => { g . throw ( 44 ) ; } , `44` ) ; shouldBe ( c1 . count , 1 ) ; } ( ) ) ; ( function ( ) { class Iterator { next ( value ) { return { value , done : false } ; } [ Symbol . iterator ] ( ) { return this ; } } function * gen ( ) { let iter = new Iterator ( ) ; yield * iter ; } let g = gen ( ) ; shouldBe ( g . next ( 0 ) . value , undefined ) ; shouldBe ( g . next ( 1 ) . value , 1 ) ; shouldBe ( g . next ( 2 ) . value , 2 ) ; shouldThrow ( ( ) => { g . throw ( 42 ) ; } , `TypeError: Delegated generator does not have a 'throw' method.` ) ; shouldThrow ( ( ) => { g . throw ( 44 ) ; } , `44` ) ; } ( ) ) ; ( function ( ) { class Iterator { next ( value ) { return { value , done : false } ; } 'throw' ( value ) { } [ Symbol . iterator ] ( ) { return this ; } } function * gen ( ) { let iter = new Iterator ( ) ; yield * iter ; } let g = gen ( ) ; shouldBe ( g . next ( 0 ) . value , undefined ) ; shouldBe ( g . next ( 1 ) . value , 1 ) ; shouldBe ( g . next ( 2 ) . value , 2 ) ; shouldThrow ( ( ) => { g . throw ( 42 ) ; } , `TypeError: Iterator result interface is not an object.` ) ; shouldThrow ( ( ) => { g . throw ( 44 ) ; } , `44` ) ; } ( ) ) ; ( function ( ) { class Iterator { next ( value ) { return { value , done : false } ; } 'throw' ( value ) { return { value , done : true } ; } [ Symbol . iterator ] ( ) { return this ; } } function * gen ( ) { let iter = new Iterator ( ) ; let result = yield * iter ; shouldBe ( result , 42 ) ; yield 21 ; } let g = gen ( ) ; shouldBe ( g . next ( 0 ) . value , undefined ) ; shouldBe ( g . next ( 1 ) . value , 1 ) ; shouldBe ( g . next ( 2 ) . value , 2 ) ; shouldBe ( g . throw ( 42 ) . value , 21 ) ; shouldBe ( g . next ( ) . done , true ) ; shouldThrow ( ( ) => { g . throw ( 44 ) ; } , `44` ) ; } ( ) ) ; ( function ( ) { class Iterator { next ( value ) { return { value , done : false } ; } 'return' ( value ) { return { value , done : false } ; } [ Symbol . iterator ] ( ) { return this ; } } function * gen ( ) { let iter = new Iterator ( ) ; let result = yield * iter ; yield result ; yield 42 ; } let g = gen ( ) ; shouldBe ( g . next ( 0 ) . value , undefined ) ; shouldBe ( g . next ( 1 ) . value , 1 ) ; shouldBe ( g . next ( 2 ) . value , 2 ) ; shouldBe ( g . return ( 42 ) . value , 42 ) ; shouldBe ( g . return ( 42 ) . done , false ) ; } ( ) ) ; ( function ( ) { function * gen ( ) { let result = yield * [ 0 , 1 , 2 ] ; yield result ; } let g = gen ( ) ; shouldBe ( g . next ( ) . value , 0 ) ; shouldBe ( g . next ( ) . value , 1 ) ; shouldBe ( g . next ( ) . value , 2 ) ; shouldBe ( g . next ( ) . value , undefined ) ; } ( ) ) ;)