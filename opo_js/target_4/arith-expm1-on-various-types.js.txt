(program (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (literal "use strict"))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable expm1OfHalf) = (singleExpression (singleExpression (singleExpression Math) . (identifierName expm1)) (arguments ( (argument (singleExpression (literal (numericLiteral 0.5)))) ))))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable validInputTestCases) = (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "undefined"))) , (arrayElement (singleExpression (literal "NaN")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "null"))) , (arrayElement (singleExpression (literal "0")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "1"))) , (arrayElement (singleExpression (singleExpression (literal "")) + (singleExpression (singleExpression (singleExpression Math) . (identifierName expm1)) (arguments ( (argument (singleExpression (literal (numericLiteral 1)))) )))))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "0"))) , (arrayElement (singleExpression (literal "0")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "-0."))) , (arrayElement (singleExpression (literal "-0")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "0.5"))) , (arrayElement (singleExpression (singleExpression (literal "")) + (singleExpression expm1OfHalf)))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "Math.PI"))) , (arrayElement (singleExpression (singleExpression (literal "")) + (singleExpression (singleExpression (singleExpression Math) . (identifierName expm1)) (arguments ( (argument (singleExpression (singleExpression Math) . (identifierName PI))) )))))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "Infinity"))) , (arrayElement (singleExpression (literal "Infinity")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "-Infinity"))) , (arrayElement (singleExpression (literal "-1")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "NaN"))) , (arrayElement (singleExpression (literal "NaN")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "\"WebKit\""))) , (arrayElement (singleExpression (literal "NaN")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "\"0.5\""))) , (arrayElement (singleExpression (singleExpression (literal "")) + (singleExpression expm1OfHalf)))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "{ valueOf: () => { return 0.5; } }"))) , (arrayElement (singleExpression (singleExpression (literal "")) + (singleExpression expm1OfHalf)))) ]))) ,) ])))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable validInputTypedTestCases) = (singleExpression (singleExpression (singleExpression validInputTestCases) . (identifierName map)) (arguments ( (argument (singleExpression (anoymousFunction (arrowFunctionParameters ( (formalParameterList (formalParameterArg (assignable element))) )) => (arrowFunctionBody { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (singleExpression eval) (arguments ( (argument (singleExpression (singleExpression (singleExpression (literal "(")) + (singleExpression (singleExpression element) [ (expressionSequence (singleExpression (literal (numericLiteral 0)))) ])) + (singleExpression (literal ")")))) )))) , (arrayElement (singleExpression (singleExpression eval) (arguments ( (argument (singleExpression (singleExpression element) [ (expressionSequence (singleExpression (literal (numericLiteral 1)))) ])) ))))) ]))) eos))))) })))) ))))) (eos ;)))) (sourceElement (statement (functionDeclaration function isIdentical ( (formalParameterList (formalParameterArg (assignable result)) , (formalParameterArg (assignable expected))) ) { (functionBody (sourceElements (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression expected) === (singleExpression expected))) ) (statement (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression result) !== (singleExpression expected))) ) (statement (returnStatement return (expressionSequence (singleExpression (literal false))) (eos ;))))) (statement (ifStatement if ( (expressionSequence (singleExpression ! (singleExpression expected))) ) (statement (returnStatement return (expressionSequence (singleExpression (singleExpression ( (expressionSequence (singleExpression (singleExpression (literal (numericLiteral 1))) / (singleExpression expected))) )) === (singleExpression ( (expressionSequence (singleExpression (singleExpression (literal (numericLiteral 1))) / (singleExpression result))) )))) (eos ;))))) (statement (returnStatement return (expressionSequence (singleExpression (literal true))) (eos ;)))) }))))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression result) !== (singleExpression result))) (eos ;)))))) }))) (sourceElement (statement (functionDeclaration function opaqueExpm1NoArgument ( ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression (singleExpression Math) . (identifierName expm1)) (arguments ( )))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueExpm1NoArgument)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueExpm1NoArgument)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testNoArgument ( ) { (functionBody (sourceElements (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e4))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable output) = (singleExpression (singleExpression opaqueExpm1NoArgument) (arguments ( ))))) (eos ;))) (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression output) === (singleExpression output))) ) (statement (block { (statementList (statement (throwStatement throw (expressionSequence (singleExpression (literal "Failed opaqueExpm1NoArgument"))) (eos ;)))) }))))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueExpm1NoArgument)) ))) > (singleExpression (literal (numericLiteral 1))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "The call without arguments should never exit."))) (eos ;)))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testNoArgument) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueAllTypesExpm1 ( (formalParameterList (formalParameterArg (assignable argument))) ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression (singleExpression Math) . (identifierName expm1)) (arguments ( (argument (singleExpression argument)) )))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueAllTypesExpm1)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueAllTypesExpm1)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testAllTypesCall ( ) { (functionBody (sourceElements (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e3))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable testCaseInput))) of (expressionSequence (singleExpression validInputTypedTestCases)) ) (statement (block { (statementList (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable output) = (singleExpression (singleExpression opaqueAllTypesExpm1) (arguments ( (argument (singleExpression (singleExpression testCaseInput) [ (expressionSequence (singleExpression (literal (numericLiteral 0)))) ])) ))))) (eos ;))) (statement (ifStatement if ( (expressionSequence (singleExpression ! (singleExpression (singleExpression isIdentical) (arguments ( (argument (singleExpression output)) , (argument (singleExpression (singleExpression testCaseInput) [ (expressionSequence (singleExpression (literal (numericLiteral 1)))) ])) ))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (singleExpression (singleExpression (singleExpression (singleExpression (singleExpression (literal "Failed testAllTypesCall for input ")) + (singleExpression (singleExpression testCaseInput) [ (expressionSequence (singleExpression (literal (numericLiteral 0)))) ])) + (singleExpression (literal " expected "))) + (singleExpression (singleExpression testCaseInput) [ (expressionSequence (singleExpression (literal (numericLiteral 1)))) ])) + (singleExpression (literal " got "))) + (singleExpression output))) (eos ;)))))) }))))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueAllTypesExpm1)) ))) > (singleExpression (literal (numericLiteral 2))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "We should have detected expm1() was polymorphic and generated a generic version."))) (eos ;)))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testAllTypesCall) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testSingleTypeCall ( ) { (functionBody (sourceElements (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable testCaseInput))) of (expressionSequence (singleExpression validInputTestCases)) ) (statement (block { (statementList (statement (expressionStatement (expressionSequence (singleExpression (singleExpression eval) (arguments ( (argument (singleExpression (literal `            function opaqueExpm1(argument) {                return Math.expm1(argument);            }            noInline(opaqueExpm1);            noOSRExitFuzzing(opaqueExpm1);            for (let i = 0; i < 1e4; ++i) {                if (!isIdentical(opaqueExpm1(${testCaseInput[0]}), ${testCaseInput[1]})) {                    throw "Failed testSingleTypeCall()";                }            }            if (numberOfDFGCompiles(opaqueExpm1) > 1)                throw "We should have compiled a single expm1 for the expected type.";        `))) )))) (eos ;)))) }))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testSingleTypeCall) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testConstant ( ) { (functionBody (sourceElements (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable testCaseInput))) of (expressionSequence (singleExpression validInputTestCases)) ) (statement (block { (statementList (statement (expressionStatement (expressionSequence (singleExpression (singleExpression eval) (arguments ( (argument (singleExpression (literal `            function opaqueExpm1OnConstant() {                return Math.expm1(${testCaseInput[0]});            }            noInline(opaqueExpm1OnConstant);            noOSRExitFuzzing(opaqueExpm1OnConstant);            for (let i = 0; i < 1e4; ++i) {                if (!isIdentical(opaqueExpm1OnConstant(), ${testCaseInput[1]})) {                    throw "Failed testConstant()";                }            }            if (numberOfDFGCompiles(opaqueExpm1OnConstant) > 1)                throw "We should have compiled a single expm1 for the expected type.";        `))) )))) (eos ;)))) }))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testConstant) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueExpm1ForSideEffects ( (formalParameterList (formalParameterArg (assignable argument))) ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression (singleExpression Math) . (identifierName expm1)) (arguments ( (argument (singleExpression argument)) )))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueExpm1ForSideEffects)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueExpm1ForSideEffects)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testSideEffect ( ) { (functionBody (sourceElements (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable testObject) = (singleExpression (objectLiteral { (propertyAssignment (propertyName (identifierName counter)) : (singleExpression (literal (numericLiteral 0)))) , (propertyAssignment (propertyName (identifierName valueOf)) : (singleExpression (anoymousFunction function ( ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression ++ (singleExpression (singleExpression this) . (identifierName counter)))) (eos ;)))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (literal (numericLiteral 0.2)))) (eos ;)))))) }))) })))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable expm1Result) = (singleExpression (singleExpression (singleExpression Math) . (identifierName expm1)) (arguments ( (argument (singleExpression (literal (numericLiteral 0.2)))) ))))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e4))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression opaqueExpm1ForSideEffects) (arguments ( (argument (singleExpression testObject)) ))) !== (singleExpression expm1Result))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "Incorrect result in testSideEffect()"))) (eos ;)))))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression testObject) . (identifierName counter)) !== (singleExpression (literal (numericLiteral 1e4))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "Failed testSideEffect()"))) (eos ;)))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueExpm1ForSideEffects)) ))) > (singleExpression (literal (numericLiteral 1))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "opaqueExpm1ForSideEffects() is predictable, it should only be compiled once."))) (eos ;)))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testSideEffect) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueExpm1ForCSE ( (formalParameterList (formalParameterArg (assignable argument))) ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression (singleExpression (singleExpression (singleExpression Math) . (identifierName expm1)) (arguments ( (argument (singleExpression argument)) ))) + (singleExpression (singleExpression (singleExpression Math) . (identifierName expm1)) (arguments ( (argument (singleExpression argument)) )))) + (singleExpression (singleExpression (singleExpression Math) . (identifierName expm1)) (arguments ( (argument (singleExpression argument)) ))))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueExpm1ForCSE)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueExpm1ForCSE)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testCSE ( ) { (functionBody (sourceElements (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable testObject) = (singleExpression (objectLiteral { (propertyAssignment (propertyName (identifierName counter)) : (singleExpression (literal (numericLiteral 0)))) , (propertyAssignment (propertyName (identifierName valueOf)) : (singleExpression (anoymousFunction function ( ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression ++ (singleExpression (singleExpression this) . (identifierName counter)))) (eos ;)))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (literal (numericLiteral 0.2)))) (eos ;)))))) }))) })))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable expm1Result) = (singleExpression (singleExpression (singleExpression Math) . (identifierName expm1)) (arguments ( (argument (singleExpression (literal (numericLiteral 0.2)))) ))))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable threeexpm1Result) = (singleExpression (singleExpression (singleExpression expm1Result) + (singleExpression expm1Result)) + (singleExpression expm1Result)))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e4))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression opaqueExpm1ForCSE) (arguments ( (argument (singleExpression testObject)) ))) !== (singleExpression threeexpm1Result))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "Incorrect result in testCSE()"))) (eos ;)))))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression testObject) . (identifierName counter)) !== (singleExpression (literal (numericLiteral 3e4))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "Failed testCSE()"))) (eos ;)))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueExpm1ForCSE)) ))) > (singleExpression (literal (numericLiteral 1))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "opaqueExpm1ForCSE() is predictable, it should only be compiled once."))) (eos ;)))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testCSE) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueExpm1ForDCE ( (formalParameterList (formalParameterArg (assignable argument))) ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression (singleExpression Math) . (identifierName expm1)) (arguments ( (argument (singleExpression argument)) )))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueExpm1ForDCE)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueExpm1ForDCE)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testDCE ( ) { (functionBody (sourceElements (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable testObject) = (singleExpression (objectLiteral { (propertyAssignment (propertyName (identifierName counter)) : (singleExpression (literal (numericLiteral 0)))) , (propertyAssignment (propertyName (identifierName valueOf)) : (singleExpression (anoymousFunction function ( ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression ++ (singleExpression (singleExpression this) . (identifierName counter)))) (eos ;)))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (literal (numericLiteral 0.2)))) (eos ;)))))) }))) })))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e4))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (expressionStatement (expressionSequence (singleExpression (singleExpression opaqueExpm1ForDCE) (arguments ( (argument (singleExpression testObject)) )))) (eos ;)))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression testObject) . (identifierName counter)) !== (singleExpression (literal (numericLiteral 1e4))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "Failed testDCE()"))) (eos ;)))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueExpm1ForDCE)) ))) > (singleExpression (literal (numericLiteral 1))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "opaqueExpm1ForDCE() is predictable, it should only be compiled once."))) (eos ;)))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testDCE) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testException ( ) { (functionBody (sourceElements (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable counter) = (singleExpression (literal (numericLiteral 0))))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueExpm1WithException ( (formalParameterList (formalParameterArg (assignable argument))) ) { (functionBody (sourceElements (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable result) = (singleExpression (singleExpression (singleExpression Math) . (identifierName expm1)) (arguments ( (argument (singleExpression argument)) ))))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression ++ (singleExpression counter))) (eos ;)))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression result)) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueExpm1WithException)) )))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable testObject) = (singleExpression (objectLiteral { (propertyAssignment (propertyName (identifierName valueOf)) : (singleExpression (anoymousFunction (arrowFunctionParameters ( )) => (arrowFunctionBody { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (literal (numericLiteral 0.1)))) (eos ;)))))) })))) })))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable expm1Result) = (singleExpression (singleExpression (singleExpression Math) . (identifierName expm1)) (arguments ( (argument (singleExpression (literal (numericLiteral 0.1)))) ))))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e3))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression opaqueExpm1WithException) (arguments ( (argument (singleExpression testObject)) ))) !== (singleExpression expm1Result))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "Incorrect result in opaqueExpm1WithException()"))) (eos ;)))))) }))))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable testThrowObject) = (singleExpression (objectLiteral { (propertyAssignment (propertyName (identifierName valueOf)) : (singleExpression (anoymousFunction (arrowFunctionParameters ( )) => (arrowFunctionBody { (functionBody (sourceElements (sourceElement (statement (throwStatement throw (expressionSequence (singleExpression testObject)) (eos ;)))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (literal (numericLiteral 0.1)))) (eos ;)))))) })))) })))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e2))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (tryStatement try (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression opaqueExpm1WithException) (arguments ( (argument (singleExpression testThrowObject)) ))) !== (singleExpression (literal (numericLiteral 8))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "This code should not be reached!!"))) (eos ;)))))) }) (catchProduction catch ( (assignable e) ) (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression e) !== (singleExpression testObject))) ) (statement (block { (statementList (statement (throwStatement throw (expressionSequence (singleExpression (literal "Wrong object thrown from opaqueExpm1WithException."))) eos))) }))))) }))))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression counter) !== (singleExpression (literal (numericLiteral 1e3))))) ) (statement (block { (statementList (statement (throwStatement throw (expressionSequence (singleExpression (literal "Invalid count in testException()"))) (eos ;)))) }))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testException) (arguments ( )))) (eos ;))))) <EOF>)