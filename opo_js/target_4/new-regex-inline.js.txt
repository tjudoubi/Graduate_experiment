(program (sourceElements (sourceElement (statement (functionDeclaration function assert ( (formalParameterList (formalParameterArg (assignable a))) ) { (functionBody (sourceElements (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression ! (singleExpression a))) ) (statement (throwStatement throw (expressionSequence (singleExpression (singleExpression Error) (arguments ( (argument (singleExpression (literal "bad assertion"))) )))) (eos ;)))))))) }))) (sourceElement statement) (sourceElement (statement function)) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testRegexpInline) (arguments ( (argument (singleExpression functor)) )))) eos))) (sourceElement (statement (block { (statementList (statement (iterationStatement for ( (singleExpression let) i =)) (statement (expressionStatement (expressionSequence (singleExpression (literal (numericLiteral 0)))) (eos ;))) (statement (expressionStatement (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 100000))))) (eos ;))) (statement (expressionStatement (expressionSequence (singleExpression (singleExpression i) ++)) (eos )))) (statement (block { (statementList (statement (expressionStatement (expressionSequence (singleExpression (singleExpression functor) (arguments ( )))) (eos ;)))) })) (statement (expressionStatement (expressionSequence (singleExpression (singleExpression gc) (arguments ( )))) (eos ;))) (statement (iterationStatement for ( (singleExpression let) i =)) (statement (expressionStatement (expressionSequence (singleExpression (literal (numericLiteral 0)))) (eos ;))) (statement (expressionStatement (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 10000000))))) (eos ;))) (statement (expressionStatement (expressionSequence (singleExpression (singleExpression i) ++)) (eos )))) (statement (block { (statementList (statement (expressionStatement (expressionSequence (singleExpression let)) eos)) (statement (expressionStatement (expressionSequence (singleExpression (singleExpression a) = (singleExpression (objectLiteral { (propertyAssignment (propertyName (identifierName value)) : (singleExpression i)) })))) (eos ;)))) })) (statement (iterationStatement for ( (singleExpression let) i =)) (statement (expressionStatement (expressionSequence (singleExpression (literal (numericLiteral 0)))) (eos ;))) (statement (expressionStatement (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 100))))) (eos ;))) (statement (expressionStatement (expressionSequence (singleExpression (singleExpression i) ++)) (eos )))) (statement (block { (statementList (statement (expressionStatement (expressionSequence (singleExpression (singleExpression functor) (arguments ( )))) (eos ;)))) }))) }))) (sourceElement (statement (functionDeclaration function toInlineGlobal ( ) { (functionBody (sourceElements (sourceElement (statement (variableStatement (variableDeclarationList (varModifier var) (variableDeclaration (assignable re) = (singleExpression (literal /cc+/)))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression assert) (arguments ( (argument (singleExpression (singleExpression (singleExpression re) . (identifierName test)) (arguments ( (argument (singleExpression (literal "ccc"))) )))) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression assert) (arguments ( (argument (singleExpression ! (singleExpression (singleExpression (singleExpression re) . (identifierName test)) (arguments ( (argument (singleExpression (literal "abc"))) ))))) )))) (eos ;)))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (literal (numericLiteral 0)))) (eos ;)))))) }))) (sourceElement (statement (functionDeclaration function withRegexp ( ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression toInlineGlobal) (arguments ( )))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier var) (variableDeclaration (assignable re) = (singleExpression (literal /(ab)+/)))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression assert) (arguments ( (argument (singleExpression (singleExpression (singleExpression re) . (identifierName test)) (arguments ( (argument (singleExpression (literal "ab"))) )))) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression assert) (arguments ( (argument (singleExpression ! (singleExpression (singleExpression (singleExpression re) . (identifierName test)) (arguments ( (argument (singleExpression (literal "ba"))) ))))) )))) (eos ;)))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (literal (numericLiteral 0)))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression withRegexp)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testRegexpInline) (arguments ( (argument (singleExpression withRegexp)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function inlineRegexpNotGlobal ( ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression let)) eos))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression toInline) = (singleExpression (anoymousFunction (arrowFunctionParameters ( )) => (arrowFunctionBody { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression let)) eos))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression re) = (singleExpression (literal /a+/)))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression assert) (arguments ( (argument (singleExpression (singleExpression (singleExpression re) . (identifierName test)) (arguments ( (argument (singleExpression (literal "aaaaaa"))) )))) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression assert) (arguments ( (argument (singleExpression ! (singleExpression (singleExpression (singleExpression re) . (identifierName test)) (arguments ( (argument (singleExpression (literal "bc"))) ))))) )))) (eos ;)))))) }))))) eos))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression toInline) (arguments ( )))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression inlineRegexpNotGlobal)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testRegexpInline) (arguments ( (argument (singleExpression inlineRegexpNotGlobal)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function toInlineRecursive ( (formalParameterList (formalParameterArg (assignable depth))) ) { (functionBody (sourceElements (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression depth) == (singleExpression (literal (numericLiteral 5))))) ) (statement (block { (statementList (statement (returnStatement return (eos ;)))) }))))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier var) (variableDeclaration (assignable re) = (singleExpression (literal /(ef)+/)))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression assert) (arguments ( (argument (singleExpression (singleExpression (singleExpression re) . (identifierName test)) (arguments ( (argument (singleExpression (literal "efef"))) )))) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression assert) (arguments ( (argument (singleExpression ! (singleExpression (singleExpression (singleExpression re) . (identifierName test)) (arguments ( (argument (singleExpression (literal "abc"))) ))))) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression toInlineRecursive) (arguments ( (argument (singleExpression (singleExpression depth) + (singleExpression (literal (numericLiteral 1))))) )))) (eos ;)))))) }))) (sourceElement (statement (functionDeclaration function regexpContainsRecursive ( ) { (functionBody (sourceElements (sourceElement (statement (variableStatement (variableDeclarationList (varModifier var) (variableDeclaration (assignable re) = (singleExpression (literal /r+/)))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression toInlineRecursive) (arguments ( (argument (singleExpression (literal (numericLiteral 0)))) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression assert) (arguments ( (argument (singleExpression (singleExpression (singleExpression re) . (identifierName test)) (arguments ( (argument (singleExpression (literal "r"))) )))) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression assert) (arguments ( (argument (singleExpression ! (singleExpression (singleExpression (singleExpression re) . (identifierName test)) (arguments ( (argument (singleExpression (literal "ab"))) ))))) )))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression regexpContainsRecursive)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testRegexpInline) (arguments ( (argument (singleExpression regexpContainsRecursive)) )))) (eos ;))))) <EOF>)