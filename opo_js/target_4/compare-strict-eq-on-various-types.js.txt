(program (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (literal "use strict"))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueKitString ( ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (literal "Kit"))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueKitString)) )))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable someObject) = (singleExpression new (singleExpression Object)))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable validInputTestCases) = (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "undefined"))) , (arrayElement (singleExpression (literal "Symbol(\"WebKit\")"))) , (arrayElement (singleExpression (literal "null"))) , (arrayElement (singleExpression (literal "true"))) , (arrayElement (singleExpression (literal "false"))) , (arrayElement (singleExpression (literal "0"))) , (arrayElement (singleExpression (literal "{ valueOf: () => { return Math.E; } }"))) , (arrayElement (singleExpression (literal "-0"))) , (arrayElement (singleExpression (literal "42"))) , (arrayElement (singleExpression (literal "-42"))) , (arrayElement (singleExpression (literal "Math.PI"))) , (arrayElement (singleExpression (literal "NaN"))) , (arrayElement (singleExpression (literal "\"WebKit\""))) , (arrayElement (singleExpression (literal "\"Web\" + opaqueKitString()"))) , (arrayElement (singleExpression (literal "new String(\"WebKit\")"))) , (arrayElement (singleExpression (literal "someObject"))) , (arrayElement (singleExpression (literal "validInputTestCases"))) ,) ])))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable leftCases) = (singleExpression (singleExpression (singleExpression validInputTestCases) . (identifierName map)) (arguments ( (argument (singleExpression (anoymousFunction (arrowFunctionParameters ( (formalParameterList (formalParameterArg (assignable element))) )) => (arrowFunctionBody { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression eval) (arguments ( (argument (singleExpression (singleExpression (singleExpression (literal "(")) + (singleExpression element)) + (singleExpression (literal ")")))) )))) (eos ;)))))) })))) ))))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable rightCases) = (singleExpression (singleExpression (singleExpression validInputTestCases) . (identifierName map)) (arguments ( (argument (singleExpression (anoymousFunction (arrowFunctionParameters ( (formalParameterList (formalParameterArg (assignable element))) )) => (arrowFunctionBody { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression eval) (arguments ( (argument (singleExpression (singleExpression (singleExpression (literal "(")) + (singleExpression element)) + (singleExpression (literal ")")))) )))) (eos ;)))))) })))) ))))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable expectedEqualResults) = (singleExpression (arrayLiteral [ elementList ])))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable expectedNotEqualResults) = (singleExpression (arrayLiteral [ elementList ])))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable testCaseInputLeft))) of (expressionSequence (singleExpression leftCases)) ) (statement (block { (statementList (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable equalResultRow) = (singleExpression (arrayLiteral [ elementList ])))) (eos ;))) (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable notEqualResultRow) = (singleExpression (arrayLiteral [ elementList ])))) (eos ;))) (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable testCaseInputRight))) of (expressionSequence (singleExpression rightCases)) ) (statement (block { (statementList (statement (expressionStatement (expressionSequence (singleExpression (singleExpression (singleExpression equalResultRow) . (identifierName push)) (arguments ( (argument (singleExpression (singleExpression testCaseInputLeft) === (singleExpression testCaseInputRight))) )))) (eos ;))) (statement (expressionStatement (expressionSequence (singleExpression (singleExpression (singleExpression notEqualResultRow) . (identifierName push)) (arguments ( (argument (singleExpression (singleExpression testCaseInputLeft) !== (singleExpression testCaseInputRight))) )))) (eos ;)))) })))) (statement (expressionStatement (expressionSequence (singleExpression (singleExpression (singleExpression expectedEqualResults) . (identifierName push)) (arguments ( (argument (singleExpression equalResultRow)) )))) (eos ;))) (statement (expressionStatement (expressionSequence (singleExpression (singleExpression (singleExpression expectedNotEqualResults) . (identifierName push)) (arguments ( (argument (singleExpression notEqualResultRow)) )))) (eos ;)))) }))))) (sourceElement (statement (functionDeclaration function isIdentical ( (formalParameterList (formalParameterArg (assignable result)) , (formalParameterArg (assignable expected))) ) { (functionBody (sourceElements (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression expected) === (singleExpression expected))) ) (statement (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression result) !== (singleExpression expected))) ) (statement (returnStatement return (expressionSequence (singleExpression (literal false))) (eos ;))))) (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression ! (singleExpression expected)) && (singleExpression (singleExpression (singleExpression (literal (numericLiteral 1))) / (singleExpression expected)) === (singleExpression - (singleExpression Infinity)))) && (singleExpression (singleExpression (singleExpression (literal (numericLiteral 1))) / (singleExpression result)) !== (singleExpression - (singleExpression Infinity))))) ) (statement (returnStatement return (expressionSequence (singleExpression (literal false))) (eos ;))))) (statement (returnStatement return (expressionSequence (singleExpression (literal true))) (eos ;)))) }))))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression result) !== (singleExpression result))) (eos ;)))))) }))) (sourceElement (statement (functionDeclaration function opaqueStrictEqualAllTypes ( (formalParameterList (formalParameterArg (assignable left)) , (formalParameterArg (assignable right))) ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression left) === (singleExpression right))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueStrictEqualAllTypes)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueStrictEqualAllTypes)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueStrictNotEqualAllTypes ( (formalParameterList (formalParameterArg (assignable left)) , (formalParameterArg (assignable right))) ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression left) !== (singleExpression right))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueStrictNotEqualAllTypes)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueStrictNotEqualAllTypes)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testAllTypesCall ( ) { (functionBody (sourceElements (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e3))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable leftCaseIndex) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression leftCaseIndex) < (singleExpression (singleExpression leftCases) . (identifierName length)))) ; (expressionSequence (singleExpression ++ (singleExpression leftCaseIndex))) ) (statement (block { (statementList (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable rightCaseIndex) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression rightCaseIndex) < (singleExpression (singleExpression rightCases) . (identifierName length)))) ; (expressionSequence (singleExpression ++ (singleExpression rightCaseIndex))) ) (statement (block { (statementList (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable strictEqualOutput) = (singleExpression (singleExpression opaqueStrictEqualAllTypes) (arguments ( (argument (singleExpression (singleExpression leftCases) [ (expressionSequence (singleExpression leftCaseIndex)) ])) , (argument (singleExpression (singleExpression rightCases) [ (expressionSequence (singleExpression rightCaseIndex)) ])) ))))) (eos ;))) (statement (ifStatement if ( (expressionSequence (singleExpression ! (singleExpression (singleExpression isIdentical) (arguments ( (argument (singleExpression strictEqualOutput)) , (argument (singleExpression (singleExpression (singleExpression expectedEqualResults) [ (expressionSequence (singleExpression leftCaseIndex)) ]) [ (expressionSequence (singleExpression rightCaseIndex)) ])) ))))) ) (statement (block { (statementList (statement (throwStatement throw (expressionSequence (singleExpression (singleExpression (singleExpression (singleExpression (singleExpression (singleExpression (literal "Failed testAllTypesCall for equality. Left = ")) + (singleExpression (singleExpression leftCases) [ (expressionSequence (singleExpression leftCaseIndex)) ])) + (singleExpression (literal ", Right = "))) + (singleExpression (singleExpression rightCases) [ (expressionSequence (singleExpression rightCaseIndex)) ])) + (singleExpression (literal ", Result = "))) + (singleExpression strictEqualOutput))) (eos ;)))) })))) (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable strictNotEqualOutput) = (singleExpression (singleExpression opaqueStrictNotEqualAllTypes) (arguments ( (argument (singleExpression (singleExpression leftCases) [ (expressionSequence (singleExpression leftCaseIndex)) ])) , (argument (singleExpression (singleExpression rightCases) [ (expressionSequence (singleExpression rightCaseIndex)) ])) ))))) (eos ;))) (statement (ifStatement if ( (expressionSequence (singleExpression ! (singleExpression (singleExpression isIdentical) (arguments ( (argument (singleExpression strictNotEqualOutput)) , (argument (singleExpression (singleExpression (singleExpression expectedNotEqualResults) [ (expressionSequence (singleExpression leftCaseIndex)) ]) [ (expressionSequence (singleExpression rightCaseIndex)) ])) ))))) ) (statement (block { (statementList (statement (throwStatement throw (expressionSequence (singleExpression (singleExpression (singleExpression (singleExpression (singleExpression (singleExpression (literal "Failed testAllTypesCall for !equality. Left = ")) + (singleExpression (singleExpression leftCases) [ (expressionSequence (singleExpression leftCaseIndex)) ])) + (singleExpression (literal ", Right = "))) + (singleExpression (singleExpression rightCases) [ (expressionSequence (singleExpression rightCaseIndex)) ])) + (singleExpression (literal ", Result = "))) + (singleExpression strictEqualOutput))) (eos ;)))) }))))) }))))) }))))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueStrictEqualAllTypes)) ))) > (singleExpression (literal (numericLiteral 5))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "opaqueStrictEqualAllTypes() should have been quickly compiled as fully polymorphic."))) (eos ;)))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression opaqueStrictNotEqualAllTypes) (arguments ( (argument (singleExpression opaqueStrictEqualAllTypes)) ))) > (singleExpression (literal (numericLiteral 5))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "opaqueStrictEqualAllTypes() should have been quickly compiled as fully polymorphic."))) (eos ;)))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testAllTypesCall) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueStrictEqualStringToAllTypes ( (formalParameterList (formalParameterArg (assignable left)) , (formalParameterArg (assignable right))) ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression left) === (singleExpression right))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueStrictEqualStringToAllTypes)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueStrictEqualStringToAllTypes)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueStrictEqualAllTypesToString ( (formalParameterList (formalParameterArg (assignable left)) , (formalParameterArg (assignable right))) ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression left) === (singleExpression right))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueStrictEqualAllTypesToString)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueStrictEqualAllTypesToString)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueStrictNotEqualStringToAllTypes ( (formalParameterList (formalParameterArg (assignable left)) , (formalParameterArg (assignable right))) ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression left) !== (singleExpression right))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueStrictNotEqualStringToAllTypes)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueStrictNotEqualStringToAllTypes)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueStrictNotEqualAllTypesToString ( (formalParameterList (formalParameterArg (assignable left)) , (formalParameterArg (assignable right))) ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression left) !== (singleExpression right))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueStrictNotEqualAllTypesToString)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueStrictNotEqualAllTypesToString)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testStringToAllCompare ( ) { (functionBody (sourceElements (sourceElement (statement (variableStatement (variableDeclarationList (varModifier const) (variableDeclaration (assignable leftStringIndex) = (singleExpression (singleExpression (singleExpression leftCases) . (identifierName indexOf)) (arguments ( (argument (singleExpression (literal "WebKit"))) ))))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e3))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable rightCaseIndex) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression rightCaseIndex) < (singleExpression (singleExpression rightCases) . (identifierName length)))) ; (expressionSequence (singleExpression ++ (singleExpression rightCaseIndex))) ) (statement (block { (statementList (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable rightCase) = (singleExpression (singleExpression rightCases) [ (expressionSequence (singleExpression rightCaseIndex)) ]))) (eos ;))) (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable strictEqualOutput) = (singleExpression (singleExpression opaqueStrictEqualStringToAllTypes) (arguments ( (argument (singleExpression (singleExpression (literal "Web")) + (singleExpression (singleExpression opaqueKitString) (arguments ( ))))) , (argument (singleExpression rightCase)) ))))) (eos ;))) (statement (ifStatement if ( (expressionSequence (singleExpression ! (singleExpression (singleExpression isIdentical) (arguments ( (argument (singleExpression strictEqualOutput)) , (argument (singleExpression (singleExpression (singleExpression expectedEqualResults) [ (expressionSequence (singleExpression leftStringIndex)) ]) [ (expressionSequence (singleExpression rightCaseIndex)) ])) ))))) ) (statement (block { (statementList (statement (throwStatement throw (expressionSequence (singleExpression (singleExpression (literal "Failed opaqueStrictEqualStringToAllTypes() with right = ")) + (singleExpression rightCase))) (eos ;)))) })))) (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable strictNotEqualOutput) = (singleExpression (singleExpression opaqueStrictNotEqualStringToAllTypes) (arguments ( (argument (singleExpression (singleExpression (literal "Web")) + (singleExpression (singleExpression opaqueKitString) (arguments ( ))))) , (argument (singleExpression rightCase)) ))))) (eos ;))) (statement (ifStatement if ( (expressionSequence (singleExpression ! (singleExpression (singleExpression isIdentical) (arguments ( (argument (singleExpression strictNotEqualOutput)) , (argument (singleExpression (singleExpression (singleExpression expectedNotEqualResults) [ (expressionSequence (singleExpression leftStringIndex)) ]) [ (expressionSequence (singleExpression rightCaseIndex)) ])) ))))) ) (statement (block { (statementList (statement (throwStatement throw (expressionSequence (singleExpression (singleExpression (literal "Failed opaqueStrictNotEqualStringToAllTypes() with right = ")) + (singleExpression rightCase))) (eos ;)))) }))))) }))))) }))))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier const) (variableDeclaration (assignable rightStringIndex) = (singleExpression (singleExpression (singleExpression leftCases) . (identifierName lastIndexOf)) (arguments ( (argument (singleExpression (literal "WebKit"))) ))))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e3))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable leftCaseIndex) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression leftCaseIndex) < (singleExpression (singleExpression leftCases) . (identifierName length)))) ; (expressionSequence (singleExpression ++ (singleExpression leftCaseIndex))) ) (statement (block { (statementList (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable leftCase) = (singleExpression (singleExpression leftCases) [ (expressionSequence (singleExpression leftCaseIndex)) ]))) (eos ;))) (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable strictEqualOutput) = (singleExpression (singleExpression opaqueStrictEqualAllTypesToString) (arguments ( (argument (singleExpression leftCase)) , (argument (singleExpression (singleExpression (literal "Web")) + (singleExpression (singleExpression opaqueKitString) (arguments ( ))))) ))))) (eos ;))) (statement (ifStatement if ( (expressionSequence (singleExpression ! (singleExpression (singleExpression isIdentical) (arguments ( (argument (singleExpression strictEqualOutput)) , (argument (singleExpression (singleExpression (singleExpression expectedEqualResults) [ (expressionSequence (singleExpression leftCaseIndex)) ]) [ (expressionSequence (singleExpression rightStringIndex)) ])) ))))) ) (statement (block { (statementList (statement (throwStatement throw (expressionSequence (singleExpression (singleExpression (literal "Failed opaqueStrictEqualAllTypesToString() with left = ")) + (singleExpression leftCase))) (eos ;)))) })))) (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable strictNotEqualOutput) = (singleExpression (singleExpression opaqueStrictNotEqualAllTypesToString) (arguments ( (argument (singleExpression leftCase)) , (argument (singleExpression (singleExpression (literal "Web")) + (singleExpression (singleExpression opaqueKitString) (arguments ( ))))) ))))) (eos ;))) (statement (ifStatement if ( (expressionSequence (singleExpression ! (singleExpression (singleExpression isIdentical) (arguments ( (argument (singleExpression strictNotEqualOutput)) , (argument (singleExpression (singleExpression (singleExpression expectedNotEqualResults) [ (expressionSequence (singleExpression leftCaseIndex)) ]) [ (expressionSequence (singleExpression rightStringIndex)) ])) ))))) ) (statement (block { (statementList (statement (throwStatement throw (expressionSequence (singleExpression (singleExpression (literal "Failed opaqueStrictNotEqualAllTypesToString() with left = ")) + (singleExpression leftCase))) (eos ;)))) }))))) }))))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueStrictEqualStringToAllTypes)) ))) > (singleExpression (literal (numericLiteral 2))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "opaqueStrictEqualStringToAllTypes() should quickly converge its types."))) (eos ;)))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueStrictEqualAllTypesToString)) ))) > (singleExpression (literal (numericLiteral 2))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "opaqueStrictEqualAllTypesToString() should quickly converge its types."))) (eos ;)))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueStrictNotEqualStringToAllTypes)) ))) > (singleExpression (literal (numericLiteral 2))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "opaqueStrictNotEqualStringToAllTypes() should quickly converge its types."))) (eos ;)))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueStrictNotEqualAllTypesToString)) ))) > (singleExpression (literal (numericLiteral 2))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "opaqueStrictNotEqualAllTypesToString() should quickly converge its types."))) (eos ;)))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testStringToAllCompare) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function compareOneTypeToAll ( ) { (functionBody (sourceElements (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable leftCaseIndex) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression leftCaseIndex) < (singleExpression (singleExpression validInputTestCases) . (identifierName length)))) ; (expressionSequence (singleExpression ++ (singleExpression leftCaseIndex))) ) (statement (block { (statementList (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable leftCase) = (singleExpression (singleExpression validInputTestCases) [ (expressionSequence (singleExpression leftCaseIndex)) ]))) (eos ;))) (statement (expressionStatement (expressionSequence (singleExpression (singleExpression eval) (arguments ( (argument (singleExpression (literal `            function opaqueStrictEqualOneTypeToAll(left, right) {                return left === right;            }            noInline(opaqueStrictEqualOneTypeToAll);            noOSRExitFuzzing(opaqueStrictEqualOneTypeToAll);            function opaqueStrictNotEqualOneTypeToAll(left, right) {                return left !== right;            }            noInline(opaqueStrictNotEqualOneTypeToAll);            noOSRExitFuzzing(opaqueStrictNotEqualOneTypeToAll);            for (let i = 0; i < 1e3; ++i) {                for (let rightCaseIndex = 0; rightCaseIndex < rightCases.length; ++rightCaseIndex) {                    let strictEqualOutput = opaqueStrictEqualOneTypeToAll(${leftCase}, rightCases[rightCaseIndex]);                    if (!isIdentical(strictEqualOutput, expectedEqualResults[${leftCaseIndex}][rightCaseIndex])) {                        throw "Failed opaqueStrictEqualOneTypeToAll() with left case = " + ${leftCase} + ", right case = " + rightCases[rightCaseIndex];                    }                    let strictNotEqualOutput = opaqueStrictNotEqualOneTypeToAll(${leftCase}, rightCases[rightCaseIndex]);                    if (!isIdentical(strictNotEqualOutput, expectedNotEqualResults[${leftCaseIndex}][rightCaseIndex])) {                        throw "Failed opaqueStrictNotEqualOneTypeToAll() with left case = " + ${leftCase} + ", right case = " + rightCases[rightCaseIndex];                    }                }            }             `))) )))) (eos ;)))) }))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression compareOneTypeToAll) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function compareAllTypesToOne ( ) { (functionBody (sourceElements (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable rightCaseIndex) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression rightCaseIndex) < (singleExpression (singleExpression validInputTestCases) . (identifierName length)))) ; (expressionSequence (singleExpression ++ (singleExpression rightCaseIndex))) ) (statement (block { (statementList (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable rightCase) = (singleExpression (singleExpression validInputTestCases) [ (expressionSequence (singleExpression rightCaseIndex)) ]))) (eos ;))) (statement (expressionStatement (expressionSequence (singleExpression (singleExpression eval) (arguments ( (argument (singleExpression (literal `            function opaqueStrictEqualAllToOne(left, right) {                return left === right;            }            noInline(opaqueStrictEqualAllToOne);            noOSRExitFuzzing(opaqueStrictEqualAllToOne);            function opaqueStrictNotEqualAllToOne(left, right) {                return left !== right;            }            noInline(opaqueStrictNotEqualAllToOne);            noOSRExitFuzzing(opaqueStrictNotEqualAllToOne);            for (let i = 0; i < 1e3; ++i) {                for (let leftCaseIndex = 0; leftCaseIndex < leftCases.length; ++leftCaseIndex) {                    let strictEqualOutput = opaqueStrictEqualAllToOne(leftCases[leftCaseIndex], ${rightCase});                    if (!isIdentical(strictEqualOutput, expectedEqualResults[leftCaseIndex][${rightCaseIndex}])) {                        throw "Failed opaqueStrictEqualAllToOne() with left case = " + leftCases[leftCaseIndex] + ", right case = " + ${rightCase};                    }                    let strictNotEqualOutput = opaqueStrictNotEqualAllToOne(leftCases[leftCaseIndex], ${rightCase});                    if (!isIdentical(strictNotEqualOutput, expectedNotEqualResults[leftCaseIndex][${rightCaseIndex}])) {                        throw "Failed opaqueStrictNotEqualAllToOne() with left case = " + leftCases[leftCaseIndex] + ", right case = " + ${rightCase};                    }                }            }             `))) )))) (eos ;)))) }))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression compareAllTypesToOne) (arguments ( )))) (eos ;))))) <EOF>)