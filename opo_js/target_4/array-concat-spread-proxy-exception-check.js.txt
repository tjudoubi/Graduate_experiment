(program (sourceElements (sourceElement statement) (sourceElement (statement function)) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression arrayEq) (arguments ( (argument (singleExpression a)) , (argument (singleExpression b)) )))) eos))) (sourceElement (statement (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression a) . (identifierName length)) !== (singleExpression (singleExpression b) . (identifierName length)))) ) (statement (returnStatement return (expressionSequence (singleExpression (literal false))) (eos ;))))) (statement (iterationStatement for ( (singleExpression let) i =)) (statement (expressionStatement (expressionSequence (singleExpression (literal (numericLiteral 0)))) (eos ;))) (statement (expressionStatement (expressionSequence (singleExpression (singleExpression i) < (singleExpression (singleExpression a) . (identifierName length)))) (eos ;))) (statement (expressionStatement (expressionSequence (singleExpression (singleExpression i) ++)) (eos )))) (statement (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression a) [ (expressionSequence (singleExpression i)) ]) !== (singleExpression (singleExpression b) [ (expressionSequence (singleExpression i)) ]))) ) (statement (returnStatement return (expressionSequence (singleExpression (literal false))) (eos ;)))))) })) (statement (returnStatement return (expressionSequence (singleExpression (literal true))) (eos ;)))) }))) (sourceElement (statement (block { (statementList (statement (expressionStatement (expressionSequence (singleExpression let)) eos)) (statement (expressionStatement (expressionSequence (singleExpression (singleExpression concat) = (singleExpression (singleExpression (singleExpression Array) . (identifierName prototype)) . (identifierName concat)))) (eos ;))) (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression concat)) )))) (eos ;))) (statement (expressionStatement (expressionSequence (singleExpression let)) eos)) (statement (expressionStatement (expressionSequence (singleExpression (singleExpression array) = (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal (numericLiteral 1)))) , (arrayElement (singleExpression (literal (numericLiteral 2)))) , (arrayElement (singleExpression (literal (numericLiteral 3))))) ])))) (eos ;))) (statement (expressionStatement (expressionSequence (singleExpression let)) eos)) statement (statement {) (statement (labelledStatement proxy : (statement (expressionStatement (expressionSequence (singleExpression p) , (singleExpression revoke)) eos))))) })))) = Proxy . revocable ( array , { get : function ( o , k ) { return o [ k ] ; } } ) ; concat . call ( p , p ) ; for ( let i = 0 ; i < 100000 ; i ++ ) { if ( ! arrayEq ( concat . call ( p , p ) , [ 1 , 2 , 3 , 1 , 2 , 3 ] ) ) throw "bad" ; } revoke ( ) ; failed = true ; try { concat . call ( p , p ) ; } catch ( e ) { failed = false ; } if ( failed ) throw "bad" })