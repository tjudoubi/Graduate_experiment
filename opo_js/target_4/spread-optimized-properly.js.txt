(program (sourceElements (sourceElement (statement (functionDeclaration function assert ( (formalParameterList (formalParameterArg (assignable b))) ) { (functionBody (sourceElements (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression ! (singleExpression b))) ) (statement (throwStatement throw (expressionSequence (singleExpression new (singleExpression (singleExpression Error) (arguments ( (argument (singleExpression (literal "Bad assertion"))) ))))) (eos ;)))))))) }))) (sourceElement (statement (functionDeclaration function test ( (formalParameterList (formalParameterArg (assignable f))) ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression f) (arguments ( )))) (eos ;)))))) }))) (sourceElement statement) (sourceElement (statement function)) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression shallowEq) (arguments ( (argument (singleExpression a)) , (argument (singleExpression b)) )))) eos))) (sourceElement (statement (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression a) . (identifierName length)) !== (singleExpression (singleExpression b) . (identifierName length)))) ) (statement (returnStatement return (expressionSequence (singleExpression (literal false))) (eos ;))))) (statement (iterationStatement for ( (singleExpression let) i =)) (statement (expressionStatement (expressionSequence (singleExpression (literal (numericLiteral 0)))) (eos ;))) (statement (expressionStatement (expressionSequence (singleExpression (singleExpression i) < (singleExpression (singleExpression a) . (identifierName length)))) (eos ;))) (statement (expressionStatement (expressionSequence (singleExpression ++ (singleExpression i))) (eos )))) (statement (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression a) [ (expressionSequence (singleExpression i)) ]) !== (singleExpression (singleExpression b) [ (expressionSequence (singleExpression i)) ]))) ) (statement (returnStatement return (expressionSequence (singleExpression (literal false))) (eos ;)))))) })) (statement (returnStatement return (expressionSequence (singleExpression (literal true))) (eos ;)))) }))) (sourceElement (statement (functionDeclaration function makeArrayIterator ( (formalParameterList (formalParameterArg (assignable arr)) , (formalParameterArg (assignable f))) ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression let)) eos))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression i) = (singleExpression (literal (numericLiteral 0))))) (eos ;)))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (objectLiteral { (propertyAssignment (propertyName (identifierName next)) ( ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression f) (arguments ( )))) (eos ;)))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression i) >= (singleExpression (singleExpression arr) . (identifierName length)))) ) (statement (returnStatement return (expressionSequence (singleExpression (objectLiteral { (propertyAssignment (propertyName (identifierName done)) : (singleExpression (literal true))) }))) (eos ;)))))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (objectLiteral { (propertyAssignment (propertyName (identifierName value)) : (singleExpression (singleExpression arr) [ (expressionSequence (singleExpression (singleExpression i) ++)) ])) , (propertyAssignment (propertyName (identifierName done)) : (singleExpression (literal false))) }))) (eos ;)))))) }) }))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression test)) eos))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression ( (expressionSequence (singleExpression (singleExpression (anoymousFunction function ( ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression let)) eos))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression arr) = (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal (numericLiteral 10)))) , (arrayElement (singleExpression (literal (numericLiteral 20))))) ])))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression (singleExpression arr) . (identifierName __proto__)) = (singleExpression (objectLiteral { (propertyAssignment (propertyName [ (singleExpression (singleExpression Symbol) . (identifierName iterator)) ]) : (singleExpression (singleExpression (singleExpression Array) . (identifierName prototype)) [ (expressionSequence (singleExpression (singleExpression Symbol) . (identifierName iterator))) ])) })))) (eos ;)))) (sourceElement (statement (functionDeclaration function bar ( (formalParameterList (formalParameterArg (assignable a))) ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression a) . (identifierName x))) (eos ;)))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (arrayLiteral [ (elementList (arrayElement ... (singleExpression a))) ]))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression bar)) )))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (singleExpression let) i))))) <missing '}'>)) = (singleExpression (literal (numericLiteral 0))))) <missing ')'>)) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 10000))))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression i) ++)) (eos ))))) (sourceElement (statement (block { (statementList (statement (expressionStatement (expressionSequence (singleExpression (singleExpression assert) (arguments ( (argument (singleExpression (singleExpression shallowEq) (arguments ( (argument (singleExpression (singleExpression bar) (arguments ( (argument (singleExpression arr)) )))) , (argument (singleExpression arr)) )))) )))) (eos ;)))) })))) } ) ; test ( function ( ) { let arr = [ 10 , 20 ] ; let count = 0 ; function callback ( ) { count ++ ; } arr . __proto__ = { [ Symbol . iterator ] : function ( ) { return makeArrayIterator ( this , callback ) ; } } ; function bar ( a ) { a . x ; return [ ... a ] ; } noInline ( bar ) ; for ( let i = 0 ; i < 10000 ; i ++ ) { let t = bar ( arr ) ; assert ( count === 3 ) ; count = 0 ; assert ( shallowEq ( t , arr ) ) ; } } ) ; test ( function ( ) { let arr = [ 10 , 20 ] ; let count = 0 ; function callback ( ) { count ++ ; } arr [ Symbol . iterator ] = function ( ) { return makeArrayIterator ( this , callback ) ; } ; function bar ( a ) { a . x ; return [ ... a ] ; } noInline ( bar ) ; for ( let i = 0 ; i < 10000 ; i ++ ) { let t = bar ( arr ) ; assert ( count === 3 ) ; count = 0 ; assert ( shallowEq ( t , arr ) ) ; } } ) ; test ( function ( ) { let arr = [ 10 , 20 ] ; arr [ Symbol . iterator ] = Array . prototype [ Symbol . iterator ] ; function bar ( a ) { a . x ; return [ ... a ] ; } noInline ( bar ) ; for ( let i = 0 ; i < 10000 ; i ++ ) { assert ( shallowEq ( bar ( arr ) , arr ) ) ; } } ) ; test ( function ( ) { let arr = [ , 20 ] ; let callCount = 0 ; Object . defineProperty ( arr , 0 , { get ( ) { ++ callCount ; return 10 ; } } ) ; function bar ( a ) { a . x ; return [ ... a ] ; } noInline ( bar ) ; for ( let i = 0 ; i < 10000 ; i ++ ) { let t = bar ( arr ) ; assert ( callCount === 1 ) ; assert ( shallowEq ( t , arr ) ) ; assert ( callCount === 2 ) ; callCount = 0 ; } } ) ; test ( function ( ) { let iter = [ ] [ Symbol . iterator ] ( ) ; let iterProto = Object . getPrototypeOf ( iter ) ; let oldNext = iterProto . next ; function hackedNext ( ) { let val = oldNext . call ( this ) ; if ( "value" in val ) { val . value ++ ; } return val ; } function test ( a ) { a . x ; return [ ... a ] ; } for ( let i = 0 ; i < 10000 ; ++ i ) { let arr = [ 1 , , 3 ] ; let callCount = 0 ; Object . defineProperty ( arr , 1 , { get : function ( ) { ++ callCount ; iterProto . next = hackedNext ; return 2 ; } } ) ; let t = test ( arr ) ; assert ( callCount === 1 ) ; assert ( t . length === 3 ) ; assert ( t [ 0 ] === 1 ) ; assert ( t [ 1 ] === 2 ) ; assert ( t [ 2 ] === 3 ) ; iterProto . next = oldNext ; } } ) ;)