(program (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (literal "use strict"))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable validInputTestCases) = (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "undefined"))) , (arrayElement (singleExpression (literal "NaN")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "null"))) , (arrayElement (singleExpression (literal "0")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "0"))) , (arrayElement (singleExpression (literal "0")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "-0."))) , (arrayElement (singleExpression (literal "-0")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "0.5"))) , (arrayElement (singleExpression (literal "0")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "-0.5"))) , (arrayElement (singleExpression (literal "-1")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "4"))) , (arrayElement (singleExpression (literal "4")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "42.1"))) , (arrayElement (singleExpression (literal "42")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "42.5"))) , (arrayElement (singleExpression (literal "42")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "42.9"))) , (arrayElement (singleExpression (literal "42")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "-42.1"))) , (arrayElement (singleExpression (literal "-43")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "-42.5"))) , (arrayElement (singleExpression (literal "-43")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "-42.9"))) , (arrayElement (singleExpression (literal "-43")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "Math.PI"))) , (arrayElement (singleExpression (literal "3")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "Infinity"))) , (arrayElement (singleExpression (literal "Infinity")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "-Infinity"))) , (arrayElement (singleExpression (literal "-Infinity")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "NaN"))) , (arrayElement (singleExpression (literal "NaN")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "\"WebKit\""))) , (arrayElement (singleExpression (literal "NaN")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "\"4\""))) , (arrayElement (singleExpression (literal "4")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "\"42.5\""))) , (arrayElement (singleExpression (literal "42")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "{ valueOf: () => { return 4; } }"))) , (arrayElement (singleExpression (literal "4")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "{ valueOf: () => { return 0; } }"))) , (arrayElement (singleExpression (literal "0")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "{ valueOf: () => { return -0; } }"))) , (arrayElement (singleExpression (literal "-0")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "{ valueOf: () => { return 0.5; } }"))) , (arrayElement (singleExpression (literal "0")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "{ valueOf: () => { return -0.5; } }"))) , (arrayElement (singleExpression (literal "-1")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "{ valueOf: () => { return Number.MIN_SAFE_INTEGER; } }"))) , (arrayElement (singleExpression (literal "-9007199254740991")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "{ valueOf: () => { return Number.MAX_SAFE_INTEGER; } }"))) , (arrayElement (singleExpression (literal "9007199254740991")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "{ valueOf: () => { return 0x80000000|0; } }"))) , (arrayElement (singleExpression (literal "-2147483648")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "{ valueOf: () => { return 0x7fffffff|0; } }"))) , (arrayElement (singleExpression (literal "2147483647")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "{ valueOf: () => { return (0x80000000|0) - 0.5; } }"))) , (arrayElement (singleExpression (literal "-2147483649")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "{ valueOf: () => { return (0x7fffffff|0) + 0.5; } }"))) , (arrayElement (singleExpression (literal "2147483647")))) ]))) ,) ])))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable validInputTypedTestCases) = (singleExpression (singleExpression (singleExpression validInputTestCases) . (identifierName map)) (arguments ( (argument (singleExpression (anoymousFunction (arrowFunctionParameters ( (formalParameterList (formalParameterArg (assignable element))) )) => (arrowFunctionBody { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (singleExpression eval) (arguments ( (argument (singleExpression (singleExpression (singleExpression (literal "(")) + (singleExpression (singleExpression element) [ (expressionSequence (singleExpression (literal (numericLiteral 0)))) ])) + (singleExpression (literal ")")))) )))) , (arrayElement (singleExpression (singleExpression eval) (arguments ( (argument (singleExpression (singleExpression element) [ (expressionSequence (singleExpression (literal (numericLiteral 1)))) ])) ))))) ]))) eos))))) })))) ))))) (eos ;)))) (sourceElement (statement (functionDeclaration function isIdentical ( (formalParameterList (formalParameterArg (assignable result)) , (formalParameterArg (assignable expected))) ) { (functionBody (sourceElements (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression expected) === (singleExpression expected))) ) (statement (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression result) !== (singleExpression expected))) ) (statement (returnStatement return (expressionSequence (singleExpression (literal false))) (eos ;))))) (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression ! (singleExpression expected)) && (singleExpression (singleExpression ( (expressionSequence (singleExpression (singleExpression (literal (numericLiteral 1))) / (singleExpression expected))) )) !== (singleExpression ( (expressionSequence (singleExpression (singleExpression (literal (numericLiteral 1))) / (singleExpression result))) ))))) ) (statement (returnStatement return (expressionSequence (singleExpression (literal false))) (eos ;))))) (statement (returnStatement return (expressionSequence (singleExpression (literal true))) (eos ;)))) }))))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression result) !== (singleExpression result))) (eos ;)))))) }))) (sourceElement (statement (functionDeclaration function opaqueFloorNoArgument ( ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression (singleExpression Math) . (identifierName floor)) (arguments ( )))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueFloorNoArgument)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueFloorNoArgument)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testNoArgument ( ) { (functionBody (sourceElements (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e4))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable output) = (singleExpression (singleExpression opaqueFloorNoArgument) (arguments ( ))))) (eos ;))) (statement (ifStatement if ( (expressionSequence (singleExpression ! (singleExpression (singleExpression isIdentical) (arguments ( (argument (singleExpression output)) , (argument (singleExpression NaN)) ))))) ) (statement (block { (statementList (statement (throwStatement throw (expressionSequence (singleExpression (literal "Failed opaqueFloorNoArgument"))) (eos ;)))) }))))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueFloorNoArgument)) ))) > (singleExpression (literal (numericLiteral 1))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "The call without arguments should never exit."))) (eos ;)))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testNoArgument) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueAllTypesFloor ( (formalParameterList (formalParameterArg (assignable argument))) ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression (singleExpression Math) . (identifierName floor)) (arguments ( (argument (singleExpression argument)) )))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueAllTypesFloor)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueAllTypesFloor)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testAllTypesCall ( ) { (functionBody (sourceElements (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e3))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable testCaseInput))) of (expressionSequence (singleExpression validInputTypedTestCases)) ) (statement (block { (statementList (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable output) = (singleExpression (singleExpression opaqueAllTypesFloor) (arguments ( (argument (singleExpression (singleExpression testCaseInput) [ (expressionSequence (singleExpression (literal (numericLiteral 0)))) ])) ))))) (eos ;))) (statement (ifStatement if ( (expressionSequence (singleExpression ! (singleExpression (singleExpression isIdentical) (arguments ( (argument (singleExpression output)) , (argument (singleExpression (singleExpression testCaseInput) [ (expressionSequence (singleExpression (literal (numericLiteral 1)))) ])) ))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (singleExpression (singleExpression (singleExpression (singleExpression (singleExpression (literal "Failed testAllTypesCall for input ")) + (singleExpression (singleExpression testCaseInput) [ (expressionSequence (singleExpression (literal (numericLiteral 0)))) ])) + (singleExpression (literal " expected "))) + (singleExpression (singleExpression testCaseInput) [ (expressionSequence (singleExpression (literal (numericLiteral 1)))) ])) + (singleExpression (literal " got "))) + (singleExpression output))) (eos ;)))))) }))))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueAllTypesFloor)) ))) > (singleExpression (literal (numericLiteral 3))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "We should have detected floor() was polymorphic and generated a generic version."))) (eos ;)))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testAllTypesCall) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueAllTypesFloorWithoutNegativeZero ( (formalParameterList (formalParameterArg (assignable argument))) ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression (singleExpression (singleExpression Math) . (identifierName floor)) (arguments ( (argument (singleExpression argument)) ))) + (singleExpression (literal (numericLiteral 0))))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueAllTypesFloorWithoutNegativeZero)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueAllTypesFloorWithoutNegativeZero)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testAllTypesWithoutNegativeZeroCall ( ) { (functionBody (sourceElements (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e3))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable testCaseInput))) of (expressionSequence (singleExpression validInputTypedTestCases)) ) (statement (block { (statementList (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable output) = (singleExpression (singleExpression opaqueAllTypesFloorWithoutNegativeZero) (arguments ( (argument (singleExpression (singleExpression testCaseInput) [ (expressionSequence (singleExpression (literal (numericLiteral 0)))) ])) ))))) (eos ;))) (statement (ifStatement if ( (expressionSequence (singleExpression ! (singleExpression (singleExpression isIdentical) (arguments ( (argument (singleExpression output)) , (argument (singleExpression (singleExpression (singleExpression testCaseInput) [ (expressionSequence (singleExpression (literal (numericLiteral 1)))) ]) + (singleExpression (literal (numericLiteral 0))))) ))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (singleExpression (singleExpression (singleExpression (singleExpression (singleExpression (literal "Failed testAllTypesWithoutNegativeZeroCall for input ")) + (singleExpression (singleExpression testCaseInput) [ (expressionSequence (singleExpression (literal (numericLiteral 0)))) ])) + (singleExpression (literal " expected "))) + (singleExpression (singleExpression testCaseInput) [ (expressionSequence (singleExpression (literal (numericLiteral 1)))) ])) + (singleExpression (literal " got "))) + (singleExpression output))) (eos ;)))))) }))))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueAllTypesFloor)) ))) > (singleExpression (literal (numericLiteral 3))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "We should have detected floor() was polymorphic and generated a generic version."))) (eos ;)))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testAllTypesWithoutNegativeZeroCall) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testSingleTypeCall ( ) { (functionBody (sourceElements (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable testCaseInput))) of (expressionSequence (singleExpression validInputTestCases)) ) (statement (block { (statementList (statement (expressionStatement (expressionSequence (singleExpression (singleExpression eval) (arguments ( (argument (singleExpression (literal `            function opaqueFloor(argument) {                return Math.floor(argument);            }            noInline(opaqueFloor);            noOSRExitFuzzing(opaqueFloor);            for (let i = 0; i < 1e4; ++i) {                if (!isIdentical(opaqueFloor(${testCaseInput[0]}), ${testCaseInput[1]})) {                    throw "Failed testSingleTypeCall()";                }            }            if (numberOfDFGCompiles(opaqueFloor) > 1)                throw "We should have compiled a single floor for the expected type.";        `))) )))) (eos ;)))) }))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testSingleTypeCall) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function checkCompileCountForUselessNegativeZero ( (formalParameterList (formalParameterArg (assignable testFunction))) ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression testFunction)) ))) <= (singleExpression (literal (numericLiteral 1))))) (eos ;)))))) }))) (sourceElement (statement (functionDeclaration function testSingleTypeWithoutNegativeZeroCall ( ) { (functionBody (sourceElements (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable testCaseInput))) of (expressionSequence (singleExpression validInputTestCases)) ) (statement (block { (statementList (statement (expressionStatement (expressionSequence (singleExpression (singleExpression eval) (arguments ( (argument (singleExpression (literal `            function opaqueFloor(argument) {                return Math.floor(argument) + 0;            }            noInline(opaqueFloor);            noOSRExitFuzzing(opaqueFloor);            for (let i = 0; i < 1e4; ++i) {                if (!isIdentical(opaqueFloor(${testCaseInput[0]}), ${testCaseInput[1]} + 0)) {                    throw "Failed testSingleTypeWithoutNegativeZeroCall()";                }            }            if (!checkCompileCountForUselessNegativeZero(opaqueFloor))                throw "We should have compiled a single floor for the expected type.";        `))) )))) (eos ;)))) }))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testSingleTypeWithoutNegativeZeroCall) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testConstant ( ) { (functionBody (sourceElements (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable testCaseInput))) of (expressionSequence (singleExpression validInputTestCases)) ) (statement (block { (statementList (statement (expressionStatement (expressionSequence (singleExpression (singleExpression eval) (arguments ( (argument (singleExpression (literal `            function opaqueFloorOnConstant() {                return Math.floor(${testCaseInput[0]});            }            noInline(opaqueFloorOnConstant);            noOSRExitFuzzing(opaqueFloorOnConstant);            for (let i = 0; i < 1e4; ++i) {                if (!isIdentical(opaqueFloorOnConstant(), ${testCaseInput[1]})) {                    throw "Failed testConstant()";                }            }            if (numberOfDFGCompiles(opaqueFloorOnConstant) > 1)                throw "We should have compiled a single floor for the expected type.";        `))) )))) (eos ;)))) }))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testConstant) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueFloorForSideEffects ( (formalParameterList (formalParameterArg (assignable argument))) ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression (singleExpression Math) . (identifierName floor)) (arguments ( (argument (singleExpression argument)) )))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueFloorForSideEffects)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueFloorForSideEffects)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testSideEffect ( ) { (functionBody (sourceElements (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable testObject) = (singleExpression (objectLiteral { (propertyAssignment (propertyName (identifierName counter)) : (singleExpression (literal (numericLiteral 0)))) , (propertyAssignment (propertyName (identifierName valueOf)) : (singleExpression (anoymousFunction function ( ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression ++ (singleExpression (singleExpression this) . (identifierName counter)))) (eos ;)))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (literal (numericLiteral 16)))) (eos ;)))))) }))) })))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable floor16) = (singleExpression (singleExpression (singleExpression Math) . (identifierName floor)) (arguments ( (argument (singleExpression (literal (numericLiteral 16)))) ))))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e4))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression opaqueFloorForSideEffects) (arguments ( (argument (singleExpression testObject)) ))) !== (singleExpression floor16))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "Incorrect result in testSideEffect()"))) (eos ;)))))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression testObject) . (identifierName counter)) !== (singleExpression (literal (numericLiteral 1e4))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "Failed testSideEffect()"))) (eos ;)))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueFloorForSideEffects)) ))) > (singleExpression (literal (numericLiteral 1))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "opaqueFloorForSideEffects() is predictable, it should only be compiled once."))) (eos ;)))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testSideEffect) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueFloorForCSE ( (formalParameterList (formalParameterArg (assignable argument))) ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression (singleExpression (singleExpression (singleExpression Math) . (identifierName floor)) (arguments ( (argument (singleExpression argument)) ))) + (singleExpression (singleExpression (singleExpression Math) . (identifierName floor)) (arguments ( (argument (singleExpression argument)) )))) + (singleExpression (singleExpression (singleExpression Math) . (identifierName floor)) (arguments ( (argument (singleExpression argument)) ))))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueFloorForCSE)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueFloorForCSE)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testCSE ( ) { (functionBody (sourceElements (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable testObject) = (singleExpression (objectLiteral { (propertyAssignment (propertyName (identifierName counter)) : (singleExpression (literal (numericLiteral 0)))) , (propertyAssignment (propertyName (identifierName valueOf)) : (singleExpression (anoymousFunction function ( ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression ++ (singleExpression (singleExpression this) . (identifierName counter)))) (eos ;)))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (literal (numericLiteral 16)))) (eos ;)))))) }))) })))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable floor16) = (singleExpression (singleExpression (singleExpression Math) . (identifierName floor)) (arguments ( (argument (singleExpression (literal (numericLiteral 16)))) ))))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable threeFloor16) = (singleExpression (singleExpression (singleExpression floor16) + (singleExpression floor16)) + (singleExpression floor16)))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e4))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression opaqueFloorForCSE) (arguments ( (argument (singleExpression testObject)) ))) !== (singleExpression threeFloor16))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "Incorrect result in testCSE()"))) (eos ;)))))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression testObject) . (identifierName counter)) !== (singleExpression (literal (numericLiteral 3e4))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "Failed testCSE()"))) (eos ;)))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueFloorForCSE)) ))) > (singleExpression (literal (numericLiteral 1))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "opaqueFloorForCSE() is predictable, it should only be compiled once."))) (eos ;)))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testCSE) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueFloorForDCE ( (formalParameterList (formalParameterArg (assignable argument))) ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression (singleExpression Math) . (identifierName floor)) (arguments ( (argument (singleExpression argument)) )))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueFloorForDCE)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueFloorForDCE)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testDCE ( ) { (functionBody (sourceElements (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable testObject) = (singleExpression (objectLiteral { (propertyAssignment (propertyName (identifierName counter)) : (singleExpression (literal (numericLiteral 0)))) , (propertyAssignment (propertyName (identifierName valueOf)) : (singleExpression (anoymousFunction function ( ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression ++ (singleExpression (singleExpression this) . (identifierName counter)))) (eos ;)))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (literal (numericLiteral 16)))) (eos ;)))))) }))) })))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e4))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (expressionStatement (expressionSequence (singleExpression (singleExpression opaqueFloorForDCE) (arguments ( (argument (singleExpression testObject)) )))) (eos ;)))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression testObject) . (identifierName counter)) !== (singleExpression (literal (numericLiteral 1e4))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "Failed testDCE()"))) (eos ;)))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueFloorForDCE)) ))) > (singleExpression (literal (numericLiteral 1))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "opaqueFloorForDCE() is predictable, it should only be compiled once."))) (eos ;)))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testDCE) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testException ( ) { (functionBody (sourceElements (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable counter) = (singleExpression (literal (numericLiteral 0))))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueFloorWithException ( (formalParameterList (formalParameterArg (assignable argument))) ) { (functionBody (sourceElements (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable result) = (singleExpression (singleExpression (singleExpression Math) . (identifierName floor)) (arguments ( (argument (singleExpression argument)) ))))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression ++ (singleExpression counter))) (eos ;)))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression result)) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueFloorWithException)) )))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable testObject) = (singleExpression (objectLiteral { (propertyAssignment (propertyName (identifierName valueOf)) : (singleExpression (anoymousFunction (arrowFunctionParameters ( )) => (arrowFunctionBody { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (literal (numericLiteral 64)))) (eos ;)))))) })))) })))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable floor64) = (singleExpression (singleExpression (singleExpression Math) . (identifierName floor)) (arguments ( (argument (singleExpression (literal (numericLiteral 64)))) ))))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e3))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression opaqueFloorWithException) (arguments ( (argument (singleExpression testObject)) ))) !== (singleExpression floor64))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "Incorrect result in opaqueFloorWithException()"))) (eos ;)))))) }))))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable testThrowObject) = (singleExpression (objectLiteral { (propertyAssignment (propertyName (identifierName valueOf)) : (singleExpression (anoymousFunction (arrowFunctionParameters ( )) => (arrowFunctionBody { (functionBody (sourceElements (sourceElement (statement (throwStatement throw (expressionSequence (singleExpression testObject)) (eos ;)))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (literal (numericLiteral 64)))) (eos ;)))))) })))) })))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e2))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (tryStatement try (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression opaqueFloorWithException) (arguments ( (argument (singleExpression testThrowObject)) ))) !== (singleExpression (literal (numericLiteral 8))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "This code should not be reached!!"))) (eos ;)))))) }) (catchProduction catch ( (assignable e) ) (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression e) !== (singleExpression testObject))) ) (statement (block { (statementList (statement (throwStatement throw (expressionSequence (singleExpression (literal "Wrong object thrown from opaqueFloorWithException."))) eos))) }))))) }))))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression counter) !== (singleExpression (literal (numericLiteral 1e3))))) ) (statement (block { (statementList (statement (throwStatement throw (expressionSequence (singleExpression (literal "Invalid count in testException()"))) (eos ;)))) }))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testException) (arguments ( )))) (eos ;))))) <EOF>)