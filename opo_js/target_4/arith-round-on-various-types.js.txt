(program (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (literal "use strict"))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable validInputTestCases) = (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "undefined"))) , (arrayElement (singleExpression (literal "NaN")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "null"))) , (arrayElement (singleExpression (literal "0")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "0"))) , (arrayElement (singleExpression (literal "0")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "-0."))) , (arrayElement (singleExpression (literal "-0")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "0.5"))) , (arrayElement (singleExpression (literal "1")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "-0.5"))) , (arrayElement (singleExpression (literal "-0")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "4"))) , (arrayElement (singleExpression (literal "4")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "42.1"))) , (arrayElement (singleExpression (literal "42")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "42.5"))) , (arrayElement (singleExpression (literal "43")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "42.9"))) , (arrayElement (singleExpression (literal "43")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "-42.1"))) , (arrayElement (singleExpression (literal "-42")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "-42.5"))) , (arrayElement (singleExpression (literal "-42")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "-42.9"))) , (arrayElement (singleExpression (literal "-43")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "Math.PI"))) , (arrayElement (singleExpression (literal "3")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "Infinity"))) , (arrayElement (singleExpression (literal "Infinity")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "-Infinity"))) , (arrayElement (singleExpression (literal "-Infinity")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "NaN"))) , (arrayElement (singleExpression (literal "NaN")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "\"WebKit\""))) , (arrayElement (singleExpression (literal "NaN")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "\"4\""))) , (arrayElement (singleExpression (literal "4")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "\"42.5\""))) , (arrayElement (singleExpression (literal "43")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "{ valueOf: () => { return 4; } }"))) , (arrayElement (singleExpression (literal "4")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "{ valueOf: () => { return 0; } }"))) , (arrayElement (singleExpression (literal "0")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "{ valueOf: () => { return -0; } }"))) , (arrayElement (singleExpression (literal "-0")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "{ valueOf: () => { return 0.5; } }"))) , (arrayElement (singleExpression (literal "1")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "{ valueOf: () => { return -0.5; } }"))) , (arrayElement (singleExpression (literal "-0")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "{ valueOf: () => { return Number.MIN_SAFE_INTEGER; } }"))) , (arrayElement (singleExpression (literal "-9007199254740991")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "{ valueOf: () => { return Number.MAX_SAFE_INTEGER; } }"))) , (arrayElement (singleExpression (literal "9007199254740991")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "{ valueOf: () => { return 0x80000000|0; } }"))) , (arrayElement (singleExpression (literal "-2147483648")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "{ valueOf: () => { return 0x7fffffff|0; } }"))) , (arrayElement (singleExpression (literal "2147483647")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "{ valueOf: () => { return (0x80000000|0) - 0.5; } }"))) , (arrayElement (singleExpression (literal "-2147483648")))) ]))) , (arrayElement (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (literal "{ valueOf: () => { return (0x7fffffff|0) + 0.5; } }"))) , (arrayElement (singleExpression (literal "2147483648")))) ]))) ,) ])))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable validInputTypedTestCases) = (singleExpression (singleExpression (singleExpression validInputTestCases) . (identifierName map)) (arguments ( (argument (singleExpression (anoymousFunction (arrowFunctionParameters ( (formalParameterList (formalParameterArg (assignable element))) )) => (arrowFunctionBody { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (arrayLiteral [ (elementList (arrayElement (singleExpression (singleExpression eval) (arguments ( (argument (singleExpression (singleExpression (singleExpression (literal "(")) + (singleExpression (singleExpression element) [ (expressionSequence (singleExpression (literal (numericLiteral 0)))) ])) + (singleExpression (literal ")")))) )))) , (arrayElement (singleExpression (singleExpression eval) (arguments ( (argument (singleExpression (singleExpression element) [ (expressionSequence (singleExpression (literal (numericLiteral 1)))) ])) ))))) ]))) eos))))) })))) ))))) (eos ;)))) (sourceElement (statement (functionDeclaration function isIdentical ( (formalParameterList (formalParameterArg (assignable result)) , (formalParameterArg (assignable expected))) ) { (functionBody (sourceElements (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression expected) === (singleExpression expected))) ) (statement (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression result) !== (singleExpression expected))) ) (statement (returnStatement return (expressionSequence (singleExpression (literal false))) (eos ;))))) (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression ! (singleExpression expected)) && (singleExpression (singleExpression ( (expressionSequence (singleExpression (singleExpression (literal (numericLiteral 1))) / (singleExpression expected))) )) !== (singleExpression ( (expressionSequence (singleExpression (singleExpression (literal (numericLiteral 1))) / (singleExpression result))) ))))) ) (statement (returnStatement return (expressionSequence (singleExpression (literal false))) (eos ;))))) (statement (returnStatement return (expressionSequence (singleExpression (literal true))) (eos ;)))) }))))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression result) !== (singleExpression result))) (eos ;)))))) }))) (sourceElement (statement (functionDeclaration function opaqueRoundNoArgument ( ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression (singleExpression Math) . (identifierName round)) (arguments ( )))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueRoundNoArgument)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueRoundNoArgument)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testNoArgument ( ) { (functionBody (sourceElements (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e4))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable output) = (singleExpression (singleExpression opaqueRoundNoArgument) (arguments ( ))))) (eos ;))) (statement (ifStatement if ( (expressionSequence (singleExpression ! (singleExpression (singleExpression isIdentical) (arguments ( (argument (singleExpression output)) , (argument (singleExpression NaN)) ))))) ) (statement (block { (statementList (statement (throwStatement throw (expressionSequence (singleExpression (literal "Failed opaqueRoundNoArgument"))) (eos ;)))) }))))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueRoundNoArgument)) ))) > (singleExpression (literal (numericLiteral 1))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "The call without arguments should never exit."))) (eos ;)))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testNoArgument) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueAllTypesRound ( (formalParameterList (formalParameterArg (assignable argument))) ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression (singleExpression Math) . (identifierName round)) (arguments ( (argument (singleExpression argument)) )))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueAllTypesRound)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueAllTypesRound)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testAllTypesCall ( ) { (functionBody (sourceElements (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e3))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable testCaseInput))) of (expressionSequence (singleExpression validInputTypedTestCases)) ) (statement (block { (statementList (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable output) = (singleExpression (singleExpression opaqueAllTypesRound) (arguments ( (argument (singleExpression (singleExpression testCaseInput) [ (expressionSequence (singleExpression (literal (numericLiteral 0)))) ])) ))))) (eos ;))) (statement (ifStatement if ( (expressionSequence (singleExpression ! (singleExpression (singleExpression isIdentical) (arguments ( (argument (singleExpression output)) , (argument (singleExpression (singleExpression testCaseInput) [ (expressionSequence (singleExpression (literal (numericLiteral 1)))) ])) ))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (singleExpression (singleExpression (singleExpression (singleExpression (singleExpression (literal "Failed testAllTypesCall for input ")) + (singleExpression (singleExpression testCaseInput) [ (expressionSequence (singleExpression (literal (numericLiteral 0)))) ])) + (singleExpression (literal " expected "))) + (singleExpression (singleExpression testCaseInput) [ (expressionSequence (singleExpression (literal (numericLiteral 1)))) ])) + (singleExpression (literal " got "))) + (singleExpression output))) (eos ;)))))) }))))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueAllTypesRound)) ))) > (singleExpression (literal (numericLiteral 3))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "We should have detected round() was polymorphic and generated a generic version."))) (eos ;)))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testAllTypesCall) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueAllTypesRoundWithoutNegativeZero ( (formalParameterList (formalParameterArg (assignable argument))) ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression (singleExpression (singleExpression Math) . (identifierName round)) (arguments ( (argument (singleExpression argument)) ))) + (singleExpression (literal (numericLiteral 0))))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueAllTypesRoundWithoutNegativeZero)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueAllTypesRoundWithoutNegativeZero)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testAllTypesWithoutNegativeZeroCall ( ) { (functionBody (sourceElements (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e3))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable testCaseInput))) of (expressionSequence (singleExpression validInputTypedTestCases)) ) (statement (block { (statementList (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable output) = (singleExpression (singleExpression opaqueAllTypesRoundWithoutNegativeZero) (arguments ( (argument (singleExpression (singleExpression testCaseInput) [ (expressionSequence (singleExpression (literal (numericLiteral 0)))) ])) ))))) (eos ;))) (statement (ifStatement if ( (expressionSequence (singleExpression ! (singleExpression (singleExpression isIdentical) (arguments ( (argument (singleExpression output)) , (argument (singleExpression (singleExpression (singleExpression testCaseInput) [ (expressionSequence (singleExpression (literal (numericLiteral 1)))) ]) + (singleExpression (literal (numericLiteral 0))))) ))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (singleExpression (singleExpression (singleExpression (singleExpression (singleExpression (literal "Failed testAllTypesWithoutNegativeZeroCall for input ")) + (singleExpression (singleExpression testCaseInput) [ (expressionSequence (singleExpression (literal (numericLiteral 0)))) ])) + (singleExpression (literal " expected "))) + (singleExpression (singleExpression testCaseInput) [ (expressionSequence (singleExpression (literal (numericLiteral 1)))) ])) + (singleExpression (literal " got "))) + (singleExpression output))) (eos ;)))))) }))))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueAllTypesRound)) ))) > (singleExpression (literal (numericLiteral 3))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "We should have detected round() was polymorphic and generated a generic version."))) (eos ;)))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testAllTypesWithoutNegativeZeroCall) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testSingleTypeCall ( ) { (functionBody (sourceElements (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable testCaseInput))) of (expressionSequence (singleExpression validInputTestCases)) ) (statement (block { (statementList (statement (expressionStatement (expressionSequence (singleExpression (singleExpression eval) (arguments ( (argument (singleExpression (literal `            function opaqueRound(argument) {                return Math.round(argument);            }            noInline(opaqueRound);            noOSRExitFuzzing(opaqueRound);            for (let i = 0; i < 1e4; ++i) {                if (!isIdentical(opaqueRound(${testCaseInput[0]}), ${testCaseInput[1]})) {                    throw "Failed testSingleTypeCall()";                }            }            if (numberOfDFGCompiles(opaqueRound) > 1)                throw "We should have compiled a single round for the expected type.";        `))) )))) (eos ;)))) }))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testSingleTypeCall) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function checkCompileCountForUselessNegativeZero ( (formalParameterList (formalParameterArg (assignable testFunction))) ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression testFunction)) ))) <= (singleExpression (literal (numericLiteral 1))))) (eos ;)))))) }))) (sourceElement (statement (functionDeclaration function testSingleTypeWithoutNegativeZeroCall ( ) { (functionBody (sourceElements (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable testCaseInput))) of (expressionSequence (singleExpression validInputTestCases)) ) (statement (block { (statementList (statement (expressionStatement (expressionSequence (singleExpression (singleExpression eval) (arguments ( (argument (singleExpression (literal `            function opaqueRound(argument) {                return Math.round(argument) + 0;            }            noInline(opaqueRound);            noOSRExitFuzzing(opaqueRound);            for (let i = 0; i < 1e4; ++i) {                if (!isIdentical(opaqueRound(${testCaseInput[0]}), ${testCaseInput[1]} + 0)) {                    throw "Failed testSingleTypeWithoutNegativeZeroCall()";                }            }            if (!checkCompileCountForUselessNegativeZero(opaqueRound))                throw "We should have compiled a single round for the expected type.";        `))) )))) (eos ;)))) }))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testSingleTypeWithoutNegativeZeroCall) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testConstant ( ) { (functionBody (sourceElements (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable testCaseInput))) of (expressionSequence (singleExpression validInputTestCases)) ) (statement (block { (statementList (statement (expressionStatement (expressionSequence (singleExpression (singleExpression eval) (arguments ( (argument (singleExpression (literal `            function opaqueRoundOnConstant() {                return Math.round(${testCaseInput[0]});            }            noInline(opaqueRoundOnConstant);            noOSRExitFuzzing(opaqueRoundOnConstant);            for (let i = 0; i < 1e4; ++i) {                if (!isIdentical(opaqueRoundOnConstant(), ${testCaseInput[1]})) {                    throw "Failed testConstant()";                }            }            if (numberOfDFGCompiles(opaqueRoundOnConstant) > 1)                throw "We should have compiled a single round for the expected type.";        `))) )))) (eos ;)))) }))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testConstant) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueRoundForSideEffects ( (formalParameterList (formalParameterArg (assignable argument))) ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression (singleExpression Math) . (identifierName round)) (arguments ( (argument (singleExpression argument)) )))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueRoundForSideEffects)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueRoundForSideEffects)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testSideEffect ( ) { (functionBody (sourceElements (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable testObject) = (singleExpression (objectLiteral { (propertyAssignment (propertyName (identifierName counter)) : (singleExpression (literal (numericLiteral 0)))) , (propertyAssignment (propertyName (identifierName valueOf)) : (singleExpression (anoymousFunction function ( ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression ++ (singleExpression (singleExpression this) . (identifierName counter)))) (eos ;)))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (literal (numericLiteral 16)))) (eos ;)))))) }))) })))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable round16) = (singleExpression (singleExpression (singleExpression Math) . (identifierName round)) (arguments ( (argument (singleExpression (literal (numericLiteral 16)))) ))))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e4))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression opaqueRoundForSideEffects) (arguments ( (argument (singleExpression testObject)) ))) !== (singleExpression round16))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "Incorrect result in testSideEffect()"))) (eos ;)))))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression testObject) . (identifierName counter)) !== (singleExpression (literal (numericLiteral 1e4))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "Failed testSideEffect()"))) (eos ;)))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueRoundForSideEffects)) ))) > (singleExpression (literal (numericLiteral 1))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "opaqueRoundForSideEffects() is predictable, it should only be compiled once."))) (eos ;)))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testSideEffect) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueRoundForCSE ( (formalParameterList (formalParameterArg (assignable argument))) ) { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (singleExpression (singleExpression (singleExpression (singleExpression Math) . (identifierName round)) (arguments ( (argument (singleExpression argument)) ))) + (singleExpression (singleExpression (singleExpression Math) . (identifierName round)) (arguments ( (argument (singleExpression argument)) )))) + (singleExpression (singleExpression (singleExpression Math) . (identifierName round)) (arguments ( (argument (singleExpression argument)) ))))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueRoundForCSE)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueRoundForCSE)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testCSE ( ) { (functionBody (sourceElements (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable testObject) = (singleExpression (objectLiteral { (propertyAssignment (propertyName (identifierName counter)) : (singleExpression (literal (numericLiteral 0)))) , (propertyAssignment (propertyName (identifierName valueOf)) : (singleExpression (anoymousFunction function ( ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression ++ (singleExpression (singleExpression this) . (identifierName counter)))) (eos ;)))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (literal (numericLiteral 16)))) (eos ;)))))) }))) })))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable round16) = (singleExpression (singleExpression (singleExpression Math) . (identifierName round)) (arguments ( (argument (singleExpression (literal (numericLiteral 16)))) ))))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable threeRound16) = (singleExpression (singleExpression (singleExpression round16) + (singleExpression round16)) + (singleExpression round16)))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e4))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression opaqueRoundForCSE) (arguments ( (argument (singleExpression testObject)) ))) !== (singleExpression threeRound16))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "Incorrect result in testCSE()"))) (eos ;)))))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression testObject) . (identifierName counter)) !== (singleExpression (literal (numericLiteral 3e4))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "Failed testCSE()"))) (eos ;)))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueRoundForCSE)) ))) > (singleExpression (literal (numericLiteral 1))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "opaqueRoundForCSE() is predictable, it should only be compiled once."))) (eos ;)))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testCSE) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueRoundForDCE ( (formalParameterList (formalParameterArg (assignable argument))) ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression (singleExpression Math) . (identifierName round)) (arguments ( (argument (singleExpression argument)) )))) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueRoundForDCE)) )))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noOSRExitFuzzing) (arguments ( (argument (singleExpression opaqueRoundForDCE)) )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testDCE ( ) { (functionBody (sourceElements (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable testObject) = (singleExpression (objectLiteral { (propertyAssignment (propertyName (identifierName counter)) : (singleExpression (literal (numericLiteral 0)))) , (propertyAssignment (propertyName (identifierName valueOf)) : (singleExpression (anoymousFunction function ( ) { (functionBody (sourceElements (sourceElement (statement (expressionStatement (expressionSequence (singleExpression ++ (singleExpression (singleExpression this) . (identifierName counter)))) (eos ;)))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (literal (numericLiteral 16)))) (eos ;)))))) }))) })))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e4))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (expressionStatement (expressionSequence (singleExpression (singleExpression opaqueRoundForDCE) (arguments ( (argument (singleExpression testObject)) )))) (eos ;)))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression testObject) . (identifierName counter)) !== (singleExpression (literal (numericLiteral 1e4))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "Failed testDCE()"))) (eos ;)))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression numberOfDFGCompiles) (arguments ( (argument (singleExpression opaqueRoundForDCE)) ))) > (singleExpression (literal (numericLiteral 1))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "opaqueRoundForDCE() is predictable, it should only be compiled once."))) (eos ;)))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testDCE) (arguments ( )))) (eos ;)))) (sourceElement (statement (functionDeclaration function testException ( ) { (functionBody (sourceElements (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable counter) = (singleExpression (literal (numericLiteral 0))))) (eos ;)))) (sourceElement (statement (functionDeclaration function opaqueRoundWithException ( (formalParameterList (formalParameterArg (assignable argument))) ) { (functionBody (sourceElements (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable result) = (singleExpression (singleExpression (singleExpression Math) . (identifierName round)) (arguments ( (argument (singleExpression argument)) ))))) (eos ;)))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression ++ (singleExpression counter))) (eos ;)))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression result)) (eos ;)))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression noInline) (arguments ( (argument (singleExpression opaqueRoundWithException)) )))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable testObject) = (singleExpression (objectLiteral { (propertyAssignment (propertyName (identifierName valueOf)) : (singleExpression (anoymousFunction (arrowFunctionParameters ( )) => (arrowFunctionBody { (functionBody (sourceElements (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (literal (numericLiteral 64)))) (eos ;)))))) })))) })))) (eos ;)))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable round64) = (singleExpression (singleExpression (singleExpression Math) . (identifierName round)) (arguments ( (argument (singleExpression (literal (numericLiteral 64)))) ))))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e3))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression opaqueRoundWithException) (arguments ( (argument (singleExpression testObject)) ))) !== (singleExpression round64))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "Incorrect result in opaqueRoundWithException()"))) (eos ;)))))) }))))) (sourceElement (statement (variableStatement (variableDeclarationList (varModifier let) (variableDeclaration (assignable testThrowObject) = (singleExpression (objectLiteral { (propertyAssignment (propertyName (identifierName valueOf)) : (singleExpression (anoymousFunction (arrowFunctionParameters ( )) => (arrowFunctionBody { (functionBody (sourceElements (sourceElement (statement (throwStatement throw (expressionSequence (singleExpression testObject)) (eos ;)))) (sourceElement (statement (returnStatement return (expressionSequence (singleExpression (literal (numericLiteral 64)))) (eos ;)))))) })))) })))) (eos ;)))) (sourceElement (statement (iterationStatement for ( (variableDeclarationList (varModifier let) (variableDeclaration (assignable i) = (singleExpression (literal (numericLiteral 0))))) ; (expressionSequence (singleExpression (singleExpression i) < (singleExpression (literal (numericLiteral 1e2))))) ; (expressionSequence (singleExpression ++ (singleExpression i))) ) (statement (block { (statementList (statement (tryStatement try (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression (singleExpression opaqueRoundWithException) (arguments ( (argument (singleExpression testThrowObject)) ))) !== (singleExpression (literal (numericLiteral 8))))) ) (statement (throwStatement throw (expressionSequence (singleExpression (literal "This code should not be reached!!"))) (eos ;)))))) }) (catchProduction catch ( (assignable e) ) (block { (statementList (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression e) !== (singleExpression testObject))) ) (statement (block { (statementList (statement (throwStatement throw (expressionSequence (singleExpression (literal "Wrong object thrown from opaqueRoundWithException."))) eos))) }))))) }))))) }))))) (sourceElement (statement (ifStatement if ( (expressionSequence (singleExpression (singleExpression counter) !== (singleExpression (literal (numericLiteral 1e3))))) ) (statement (block { (statementList (statement (throwStatement throw (expressionSequence (singleExpression (literal "Invalid count in testException()"))) (eos ;)))) }))))))) }))) (sourceElement (statement (expressionStatement (expressionSequence (singleExpression (singleExpression testException) (arguments ( )))) (eos ;))))) <EOF>)